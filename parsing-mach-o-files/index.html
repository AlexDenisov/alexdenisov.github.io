<!DOCTYPE html>




<html class="no-js" lang="en">

<head>
  <meta charset="UTF-8">

  


  
  <title>Parsing Mach-O files - Low Level Bits ðŸ‡ºðŸ‡¦</title>
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <meta name="keywords" content="mach-o ,macho ,linker ,parse mach-o ,parse object files ,object code ,shared libraries ,mach-o memory layout ,memory layout ,segment load command ,load command ,file format ,object type ,reverse engineering" />
  

  
  <meta name="description" content="The article covers basics of Mach-O parsing. If you&#39;re looking for a &#39;how to start&#39;, then you are at the right place." />
  

  <link rel="shortcut icon" href="/favicon.png" type="image/x-icon" />

  
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300' rel='stylesheet' type='text/css'>

  
  
  <link href="https://lowlevelbits.org/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://lowlevelbits.org/css/bootstrap-responsive.min.css" rel="stylesheet">
  <link href="https://lowlevelbits.org/css/socialicons.css" rel="stylesheet">
  <link href="https://lowlevelbits.org/css/template.css" rel="stylesheet">
  
  <link href="https://lowlevelbits.org/css/colors/color-nytimes.css" rel="stylesheet" id="colorcss">

  
  <script src="https://lowlevelbits.org/js/modernizr.js"></script>

  
  <script defer src='https://static.cloudflareinsights.com/beacon.min.js'
    data-cf-beacon='{"token": "b911a163ce714374a123a7d59d6c1342"}'></script>

  
  

  
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@1101_debian" />
<meta name="twitter:title" content="Parsing Mach-O files" />
<meta name="twitter:description" content="The article covers basics of Mach-O parsing. If you&#39;re looking for a &#39;how to start&#39;, then you are at the right place." />

<meta name="twitter:image" content="https://lowlevelbits.org/img/parse-mach-o-files/macho_memory_layout.png" />



  <script id="mcjs">!function(c,h,i,m,p){m=c.createElement(h),p=c.getElementsByTagName(h)[0],m.async=1,m.src=i,p.parentNode.insertBefore(m,p)}(document,"script","https://chimpstatic.com/mcjs-connected/js/users/aaa39cd123ecae87821d0d66a/cc68a3d3a46158689b68653cc.js");</script>

  <script defer data-domain="lowlevelbits.org" src="https://plausible.io/js/plausible.js"></script>
  <script>window.plausible = window.plausible || function () { (window.plausible.q = window.plausible.q || []).push(arguments) }</script>

  <link rel="canonical" href="https://lowlevelbits.org/parsing-mach-o-files/" />

</head>

<body>

  <div class="container">

    <div class="masthead clearfix">

  

  <div>
    <a href="/"><img id="logo" src="https://lowlevelbits.org/img/lowlevelbits.png" alt="Low Level Bits">
    </a>
    <ul id="nav" class="nav ww-nav pull-right hidden-phone">
      <li><a href="https://lowlevelbits.org/about">About</a></li>
    </ul>
  </div>

</div>

    <hr>

    <div class="row main-content">
      <div class="offset3 span7 zone-content">
        <article>
          <h1>Parsing Mach-O files</h1>
          <div>
            <p class="post-page-date">
              <i>Published on <time datetime="2015-08-20 18:30:00 &#43;0200 CEST" pubdate>Aug 20, 2015</time></i>
            </p>
          </div>

          

          <div>
            <p>This article describes how to parse Mach-O file and explains its format a little bit. Itâ€™s not a definitive guide, though it might be helpful if you donâ€™t know where to start.
For more information consider reading official documentation and header files provided by operating system.</p>
<!-- more -->
<h2 id="what-is-mach-o-file">What is Mach-O file</h2>
<p>Brief description taken from <a href="https://en.wikipedia.org/wiki/Mach-O">Wikipedia</a>:</p>
<blockquote>
<p>Mach-O, short for Mach object file format, is a file format for executables, object code, shared libraries, dynamically-loaded code, and core dumps. A replacement for the a.out format, Mach-O offers more extensibility and faster access to information in the symbol table.</p>
<p>Mach-O is used by most systems based on the Mach kernel. NeXTSTEP, OS X, and iOS are examples of systems that have used this format for native executables, libraries and object code.</p>
</blockquote>
<h2 id="mach-o-format">Mach-O format</h2>
<p>Mach-O doesnâ€™t have any special format like XML/YAML/JSON/whatnot, itâ€™s just a binary stream of bytes grouped in meaningful data chunks. These chunks contain a meta-information, e.g.: byte order, cpu type, size of the chunk and so on.</p>
<p>Typical Mach-O file (<a href="https://github.com/aidansteele/osx-abi-macho-file-format-reference">copy of the (now removed) official documentation</a>) consists of a three regions:</p>
<ol>
<li>Header - contains general information about the binary: byte order (magic number), cpu type, amount of load commands etc.</li>
<li>Load Commands - itâ€™s kind of a table of contents, that describes position of segments, symbol table, dynamic symbol table etc. Each load command includes a meta-information, such as type of command, its name, position in a binary and so on.</li>
<li>Data - usually the biggest part of object file. It contains code and data, such as symbol tables, dynamic symbol tables and so on.</li>
</ol>
<p>Here is a simplified graphical representation:</p>
<p><img src="/img/parse-mach-o-files/macho_header.png"
style=" display: block;
margin-left: auto;
margin-right: auto;
width: 60%;
height: auto;" /></p>
<p>There are two types of object files on OS X: Mach-O files and Universal Binaries, also so-called Fat files. The difference between them: Mach-O file contains object code for one architecture (i386, x86_64, arm64, etc.) while Fat binaries might contain several object files, hence contain object code for different architectures (i386 and x86_64, arm and arm64, etc.)</p>
<p>The structure of a Fat file is pretty straightforward: fat header followed by Mach-O files:</p>
<p><img src="/img/parse-mach-o-files/fat_header.png"
style=" display: block;
margin-left: auto;
margin-right: auto;
width: 40%;
height: auto;" /></p>
<h2 id="parse-mach-o-file">Parse Mach-O file</h2>
<p>OS X doesnâ€™t provide us with any <code>libmacho</code> or something similar, the only thing we have here - a set of C structures defined under <code>/usr/include/mach-o/*</code>, hence we need to implement parsing on our own. It might be tricky, but itâ€™s not that hard.</p>
<h3 id="memory-representation">Memory Representation</h3>
<p>Before we start with parsing letâ€™s look at detailed representation of a Mach-O file. For simplicity the following object file is a Mach-O file (not a fat file) for i386 with just two data entries that are segments.</p>
<p><img src="/img/parse-mach-o-files/sample_macho.png"
style=" display: block;
margin-left: auto;
margin-right: auto;
width: 40%;
height: auto;" /></p>
<p>The only structures we need to represent the file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> mach_header {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>      magic;
</span></span><span style="display:flex;"><span>  cpu_type_t    cputype;
</span></span><span style="display:flex;"><span>  cpu_subtype_t cpusubtype;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>      filetype;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>      ncmds;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>      sizeofcmds;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>      flags;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> segment_command {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>  cmd;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>  cmdsize;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span>      segname[<span style="color:#ae81ff">16</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>  vmaddr;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>  vmsize;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>  fileoff;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>  filesize;
</span></span><span style="display:flex;"><span>  vm_prot_t maxprot;
</span></span><span style="display:flex;"><span>  vm_prot_t initprot;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>  nsects;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span>  flags;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Here is how memory mapping looks like:</p>
<p><img src="/img/parse-mach-o-files/macho_memory_layout.png"
style=" display: block;
margin-left: auto;
margin-right: auto;
width: 100%;
height: auto;" /></p>
<p>If you want to read particular info from a file, you just need a correct data structure and an offset.</p>
<h3 id="parsing">Parsing</h3>
<p>Let&rsquo;s write a program that&rsquo;ll read mach-o or fat file and print names of each segment and an arch for which it was built.</p>
<p>At the end we might have something similar:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ ./segname_dumper some_binary
</span></span><span style="display:flex;"><span>i386
</span></span><span style="display:flex;"><span>segname __PAGEZERO
</span></span><span style="display:flex;"><span>segname __TEXT
</span></span><span style="display:flex;"><span>segname __LINKEDIT
</span></span></code></pre></div><h4 id="driver">Driver</h4>
<p>Let&rsquo;s start with a simple &lsquo;driver&rsquo;.</p>
<p>There are at least two possible ways to parse such files: load content into memory and work with buffer directly or open a file and jump back and forth through it. Both approaches have their own pros and cons, but I&rsquo;ll stick to a second one. Also, I assume that no one going to use the program in a wrong way, hence no error handling whatsoever.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach-o/loader.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mach-o/swap.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_segments</span>(FILE <span style="color:#f92672">*</span>obj_file);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>argv[]) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>filename <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>  FILE <span style="color:#f92672">*</span>obj_file <span style="color:#f92672">=</span> fopen(filename, <span style="color:#e6db74">&#34;rb&#34;</span>);
</span></span><span style="display:flex;"><span>  dump_segments(obj_file);
</span></span><span style="display:flex;"><span>  fclose(obj_file);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_segments</span>(FILE <span style="color:#f92672">*</span>obj_file) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Driver
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h4 id="magic-numbers-cpu-and-endianness">Magic numbers, CPU and Endianness</h4>
<p>To read at least the object file header we need to get all the information we need: CPU arch (32 bit or 64 bit) and the Byte Order. But first we need to retrieve a magic number:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">uint32_t</span> <span style="color:#a6e22e">read_magic</span>(FILE <span style="color:#f92672">*</span>obj_file, <span style="color:#66d9ef">int</span> offset) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> magic;
</span></span><span style="display:flex;"><span>  fseek(obj_file, offset, SEEK_SET);
</span></span><span style="display:flex;"><span>  fread(<span style="color:#f92672">&amp;</span>magic, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint32_t</span>), <span style="color:#ae81ff">1</span>, obj_file);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> magic;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_segments</span>(FILE <span style="color:#f92672">*</span>obj_file) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> magic <span style="color:#f92672">=</span> read_magic(obj_file, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The function <code>read_magic</code> is pretty straitforward, though one thing there might look weird: <code>fseek</code>. The problem is that whenever somebody read from a file, the internal <code>_offset</code> of the file changes. It&rsquo;s better to specify the offset explicitly, to ensure that we read what we actually want to read. Also, this small trick will be useful later on.</p>
<p>Structures that represent object file with 32 and 64 bits are different (e.g.: <code>mach_header</code> and <code>mach_header_64</code>), to choose which to use we need to check file&rsquo;s architecture:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">is_magic_64</span>(<span style="color:#66d9ef">uint32_t</span> magic) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> magic <span style="color:#f92672">==</span> MH_MAGIC_64 <span style="color:#f92672">||</span> magic <span style="color:#f92672">==</span> MH_CIGAM_64;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_segments</span>(FILE <span style="color:#f92672">*</span>obj_file) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> magic <span style="color:#f92672">=</span> read_magic(obj_file, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> is_64 <span style="color:#f92672">=</span> is_magic_64(magic);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>MH_MAGIC_64</code> and <code>MH_CIGAM_64</code> are &lsquo;magic&rsquo; numbers provided by the system. Second one looks even more magicly than first one. Explanation is following.</p>
<p>Due to historical reasons different computers might use different <a href="https://en.wikipedia.org/wiki/Endianness">byte order</a>: Big Endian (left to right) and Little Endian (right to left). Magic numbers store this information as well: <code>MH_CIGAM</code> and <code>MH_CIGAM_64</code> says that byte order differs from host OS, hence all the bytes should be swapped:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">should_swap_bytes</span>(<span style="color:#66d9ef">uint32_t</span> magic) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> magic <span style="color:#f92672">==</span> MH_CIGAM <span style="color:#f92672">||</span> magic <span style="color:#f92672">==</span> MH_CIGAM_64;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_segments</span>(FILE <span style="color:#f92672">*</span>obj_file) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> magic <span style="color:#f92672">=</span> read_magic(obj_file, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> is_64 <span style="color:#f92672">=</span> is_magic_64(magic);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> is_swap <span style="color:#f92672">=</span> should_swap_bytes(magic);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="mach-o-header">Mach-O Header</h4>
<p>Finally we can read <code>mach_header</code>. Let&rsquo;s first introduce generic function for reading data from a file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">load_bytes</span>(FILE <span style="color:#f92672">*</span>obj_file, <span style="color:#66d9ef">int</span> offset, <span style="color:#66d9ef">int</span> size) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf <span style="color:#f92672">=</span> calloc(<span style="color:#ae81ff">1</span>, size);
</span></span><span style="display:flex;"><span>  fseek(obj_file, offset, SEEK_SET);
</span></span><span style="display:flex;"><span>  fread(buf, size, <span style="color:#ae81ff">1</span>, obj_file);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> buf;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Note: The data should be freed after usage!</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_mach_header</span>(FILE <span style="color:#f92672">*</span>obj_file, <span style="color:#66d9ef">int</span> offset, <span style="color:#66d9ef">int</span> is_64, <span style="color:#66d9ef">int</span> is_swap) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (is_64) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> header_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> mach_header_64);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> mach_header_64 <span style="color:#f92672">*</span>header <span style="color:#f92672">=</span> load_bytes(obj_file, offset, header_size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (is_swap) {
</span></span><span style="display:flex;"><span>      swap_mach_header_64(header, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    free(header);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> header_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> mach_header);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> mach_header <span style="color:#f92672">*</span>header <span style="color:#f92672">=</span> load_bytes(obj_file, offset, header_size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (is_swap) {
</span></span><span style="display:flex;"><span>      swap_mach_header(header, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    free(header);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  free(buffer);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_segments</span>(FILE <span style="color:#f92672">*</span>obj_file) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> magic <span style="color:#f92672">=</span> read_magic(obj_file, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> is_64 <span style="color:#f92672">=</span> is_magic_64(magic);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> is_swap <span style="color:#f92672">=</span> should_swap_bytes(magic);
</span></span><span style="display:flex;"><span>  dump_mach_header(obj_file, <span style="color:#ae81ff">0</span>, is_64, is_swap);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we introduced another function <code>dump_mach_header</code> to not mess up &lsquo;driver&rsquo; function.
The next step is to read all segment commands and print their names.
The problem is that mach-o files usually contain other commands as well. If you recall the first field of <code>segment_command</code> structure is a <code>uint32_t cmd;</code>, this field represents type of a command.
Here is another structure provided by the system that we&rsquo;ll use:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> load_command {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> cmd;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> cmdsize;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Besides all the information <code>mach_header</code> has number of load commands, so we can just iterate over and skip commands we&rsquo;re not interested in. Also, we need to calculate offset where the header ends. Here is the final version of <code>dump_mach_header</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_mach_header</span>(FILE <span style="color:#f92672">*</span>obj_file, <span style="color:#66d9ef">int</span> offset, <span style="color:#66d9ef">int</span> is_64, <span style="color:#66d9ef">int</span> is_swap) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint32_t</span> ncmds;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> load_commands_offset <span style="color:#f92672">=</span> offset;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (is_64) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> header_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> mach_header_64);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> mach_header_64 <span style="color:#f92672">*</span>header <span style="color:#f92672">=</span> load_bytes(obj_file, offset, header_size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (is_swap) {
</span></span><span style="display:flex;"><span>      swap_mach_header_64(header, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ncmds <span style="color:#f92672">=</span> header<span style="color:#f92672">-&gt;</span>ncmds;
</span></span><span style="display:flex;"><span>    load_commands_offset <span style="color:#f92672">+=</span> header_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    free(header);
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> header_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> mach_header);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> mach_header <span style="color:#f92672">*</span>header <span style="color:#f92672">=</span> load_bytes(obj_file, offset, header_size);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (is_swap) {
</span></span><span style="display:flex;"><span>      swap_mach_header(header, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ncmds <span style="color:#f92672">=</span> header<span style="color:#f92672">-&gt;</span>ncmds;
</span></span><span style="display:flex;"><span>    load_commands_offset <span style="color:#f92672">+=</span> header_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    free(header);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  dump_segment_commands(obj_file, load_commands_offset, is_swap, ncmds);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="segment-command">Segment Command</h4>
<p>It&rsquo;s time to dump all segment names:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dump_segment_commands</span>(FILE <span style="color:#f92672">*</span>obj_file, <span style="color:#66d9ef">int</span> offset, <span style="color:#66d9ef">int</span> is_swap, <span style="color:#66d9ef">uint32_t</span> ncmds) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> actual_offset <span style="color:#f92672">=</span> offset;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span>  i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ncmds; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> load_command <span style="color:#f92672">*</span>cmd <span style="color:#f92672">=</span> load_bytes(obj_file, actual_offset, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> load_command));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (is_swap) {
</span></span><span style="display:flex;"><span>      swap_load_command(cmd, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cmd<span style="color:#f92672">-&gt;</span>cmd <span style="color:#f92672">==</span> LC_SEGMENT_64) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> segment_command_64 <span style="color:#f92672">*</span>segment <span style="color:#f92672">=</span> load_bytes(obj_file, actual_offset, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> segment_command_64));
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (is_swap) {
</span></span><span style="display:flex;"><span>        swap_segment_command_64(segment, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      printf(<span style="color:#e6db74">&#34;segname: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, segment<span style="color:#f92672">-&gt;</span>segname);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      free(segment);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (cmd<span style="color:#f92672">-&gt;</span>cmd <span style="color:#f92672">==</span> LC_SEGMENT) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">struct</span> segment_command <span style="color:#f92672">*</span>segment <span style="color:#f92672">=</span> load_bytes(obj_file, actual_offset, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> segment_command));
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (is_swap) {
</span></span><span style="display:flex;"><span>        swap_segment_command(segment, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      printf(<span style="color:#e6db74">&#34;segname: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, segment<span style="color:#f92672">-&gt;</span>segname);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      free(segment);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    actual_offset <span style="color:#f92672">+=</span> cmd<span style="color:#f92672">-&gt;</span>cmdsize;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    free(cmd);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function doesn&rsquo;t need <code>is_64</code> parameter, because we can infer it from <code>cmd</code> type itself (<code>LC_SEGMENT</code>/<code>LC_SEGMENT_64</code>). If it&rsquo;s not a segment, then we just skip the command and move forward to the next one.</p>
<h4 id="cpu-name">CPU name</h4>
<p>The last thing I want to show is how to retrieve the name of a processor based on a <code>cputype</code> from <code>mach_header</code>.
I believe this is not the best option, but it&rsquo;s acceptable for this artificial example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _cpu_type_names {
</span></span><span style="display:flex;"><span>  cpu_type_t cputype;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>cpu_name;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> _cpu_type_names cpu_type_names[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  { CPU_TYPE_I386, <span style="color:#e6db74">&#34;i386&#34;</span> },
</span></span><span style="display:flex;"><span>  { CPU_TYPE_X86_64, <span style="color:#e6db74">&#34;x86_64&#34;</span> },
</span></span><span style="display:flex;"><span>  { CPU_TYPE_ARM, <span style="color:#e6db74">&#34;arm&#34;</span> },
</span></span><span style="display:flex;"><span>  { CPU_TYPE_ARM64, <span style="color:#e6db74">&#34;arm64&#34;</span> }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">cpu_type_name</span>(cpu_type_t cpu_type) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> cpu_type_names_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(cpu_type_names) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> _cpu_type_names);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> cpu_type_names_size; i<span style="color:#f92672">++</span> ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (cpu_type <span style="color:#f92672">==</span> cpu_type_names[i].cputype) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> cpu_type_names[i].cpu_name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;unknown&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>OS X provides <code>CPU_TYPE_*</code> for a lot of CPUs, so we can &rsquo;easily&rsquo; associate particular magic number with a string literal. To print name of a CPU we need to modify <code>dump_mach_header</code> a bit:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> header_size <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> mach_header_64);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> mach_header_64 <span style="color:#f92672">*</span>header <span style="color:#f92672">=</span> load_bytes(obj_file, offset, header_size);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (is_swap) {
</span></span><span style="display:flex;"><span>  swap_mach_header_64(header, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>ncmds <span style="color:#f92672">=</span> header<span style="color:#f92672">-&gt;</span>ncmds;
</span></span><span style="display:flex;"><span>load_commands_offset <span style="color:#f92672">+=</span> header_size;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>printf(<span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, cpu_type_name(header<span style="color:#f92672">-&gt;</span>cputype)); <span style="color:#75715e">// &lt;-
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>free(header);
</span></span></code></pre></div><h4 id="fat-objects">Fat objects</h4>
<p>The article is already way too big, so I&rsquo;m not going to describe how to handle Fat objects, but you can find implementation here: <a href="https://github.com/AlexDenisov/segment_dumper">segment_dumper</a></p>
<h2 id="whats-next">What&rsquo;s next</h2>
<p>That&rsquo;s pretty much it.</p>
<p>Here is a set of links that might be useful if you want to dig deeper and learn more about mach-o:</p>
<ul>
<li><a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Conceptual/MachORuntime/index.html">OS X ABI Mach-O File Format Reference</a> - official documentation from Apple</li>
<li><a href="http://sourceforge.net/projects/machoview/">MachOView</a> - is a visual Mach-O file browser. It provides a complete solution for exploring and in-place editing Intel and ARM binaries.</li>
<li><a href="http://www.objc.io/issues/6-build-tools/mach-o-executables/">Mach-O Executables</a> - nice article from <a href="http://www.objc.io">objc.io</a>.</li>
<li><a href="https://github.com/AlexDenisov/bitcode_retriever">bitcode_retriever</a> - simple C program that retrieves <a href="http://llvm.org/docs/BitCodeFormat.html">Bitcode</a> from Mach-O binaries.</li>
<li><a href="https://github.com/AlexDenisov/segment_dumper">segment_dumper</a> - source code from this article.</li>
</ul>
<p><strong>Happy hacking!</strong></p>
<p><strong>P.S.</strong> This is a supplementary material for the next post, which will cover &rsquo;new&rsquo; <a href="https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35-SW2">Bitcode feature</a> from Apple.</p>

          </div>
        </article>

        <div>
          <hr />
          <p class="post-page-rfc">
            <a href="mailto:alex@lowlevelbits.org">Drop me a line</a> or ping me on
            <a href="https://twitter.com/1101_debian">twitter</a> or <a href="https://mastodon.social/@AlexDenisov">Mastodon</a> if you have questions!
          </p>

          <hr />
          <a href="https://www.buymeacoffee.com/AlexDenisov" target="_blank"><img
              src="https://cdn.buymeacoffee.com/buttons/v2/default-blue.png" alt="Buy Me A Coffee"
              style="height: 40px !important;width: 145px !important;"></a>
        </div>

      </div>

    </div>

    <hr>

<div class="row triple-row">

  <div id="triple-first" class="span4 triple">
    <div class="zone">
  <article class="widget-html-widget widget categories-widget">
    <header>
      <h1>Favorite Categories</h1>
    </header>

    

    
    
    
    

    

    
    
    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    
    
    
    

    

    
    
    
    

    

    
    
    

    <ul>
      
      
      <li>
        <a href="https://lowlevelbits.org/categories/llvm/">llvm (11)</a>
      </li>
      
      
      
      
      
      <li>
        <a href="https://lowlevelbits.org/categories/clang/">clang (4)</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      <li>
        <a href="https://lowlevelbits.org/categories/systems-programming/">systems programming (2)</a>
      </li>
      
      
      
      <li>
        <a href="https://lowlevelbits.org/categories/reverse-engineering/">reverse engineering (2)</a>
      </li>
      
      
      
      
      
      <li>
        <a href="https://lowlevelbits.org/categories/mutation-testing/">mutation testing (2)</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </article>
</div>
  </div>

  <div id="triple-second" class="span4 triple">
    <div class="zone">
  <article class="widget-html-widget widget recent-posts-widget">

    <header>
      <h1>Recent Posts</h1>
    </header>

    <ul>
      
      
      <li>
        <a href="https://lowlevelbits.org/compiling-ruby-part-2/"> Compiling Ruby. Part 2: RiteVM</a>
      </li>
      
      
      
      
      
      <li>
        <a href="https://lowlevelbits.org/compiling-ruby-part-1/"> Compiling Ruby. Part 1: Compilers vs. Interpreters</a>
      </li>
      
      
      
      <li>
        <a href="https://lowlevelbits.org/compiling-ruby-part-0/"> Compiling Ruby. Part 0: Motivation</a>
      </li>
      
      
      
      <li>
        <a href="https://lowlevelbits.org/how-to-learn-compilers-llvm-edition/"> How to learn compilers: LLVM Edition</a>
      </li>
      
      
      
      <li>
        <a href="https://lowlevelbits.org/llvm-meets-code-property-graphs/"> LLVM meets Code Property Graphs</a>
      </li>
      
      
    </ul>

  </article>
</div>
  </div>

  <div id="triple-third" class="span4 triple">
    

<div class="zone">
  <article class="widget widget-html-widget share-connect-widget">
    <header>
      <h1>Connect</h1>
    </header>
    <ul>
      <li><a href="mailto:alex@lowlevelbits.org" target="_blank">E-Mail</a></li>
      <li><a href="https://mastodon.social/@AlexDenisov" target="_blank">Mastodon</a></li>
      <li><a href="https://twitter.com/1101_debian" target="_blank">Twitter</a></li>
      <li><a href="https://lowlevelbits.org/atom.xml" type="application/rss+xml" target="_blank">RSS</a></li>
      <li><a href="https://lowlevelbits.org/subscribe">Mailing list</a></li>

    </ul>
    
  </article>
</div>
  </div>
</div>

<hr>

<div class="row">
  <div class="copyright span12">Copyright &copy; 2014-2022 - Low Level Bits ðŸ‡ºðŸ‡¦ by Alex Denisov</div>
</div>

  </div> 


  


<script src="https://lowlevelbits.org/js/jquery-1.9.1.js"></script>
<script src="https://lowlevelbits.org/js/bootstrap.js"></script>
<script src="https://lowlevelbits.org/js/tinynav.js"></script>
<script src="https://lowlevelbits.org/js/template.js"></script>
</body>

</html>