<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>virtual machines on Low Level Bits ðŸ‡ºðŸ‡¦</title>
    <link>https://lowlevelbits.org/tags/virtual-machines/</link>
    <description>Recent content in virtual machines on Low Level Bits ðŸ‡ºðŸ‡¦</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>alex@lowlevelbits.org (Alex Denisov)</managingEditor>
    <webMaster>alex@lowlevelbits.org (Alex Denisov)</webMaster>
    <lastBuildDate>Fri, 22 Dec 2023 02:00:00 +0100</lastBuildDate>
    <atom:link href="" rel="self" type="application/rss+xml" />
    

      
        <item>
        <title>Compiling Ruby. Part 5: exceptions</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-5/</link>
        <pubDate>Fri, 22 Dec 2023</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-5/</guid>
        <description>&lt;h3 id=&#34;call-stack-stack-frames-and-program-counter&#34;&gt;Call Stack, Stack Frames, and Program Counter&lt;/h3&gt;
&lt;p&gt;During the program execution, a machine maintains a pointer to the instruction being executed. It&amp;rsquo;s called &lt;a href=&#34;https://en.wikipedia.org/wiki/Program_counter&#34;&gt;Program Counter&lt;/a&gt; (or &lt;code&gt;Instruction Pointer&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;When you call a method (or send a message if we are speaking of Ruby), the program counter is set to the first instruction on the called function (&lt;code&gt;callee&lt;/code&gt;).
The program somehow needs to know how to get back to the call site once the &amp;ldquo;child&amp;rdquo; method has completed its execution.&lt;/p&gt;
&lt;p&gt;This information is typically maintained using the concept of a &lt;a href=&#34;https://en.wikipedia.org/wiki/Call_stack&#34;&gt;Call Stack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Consider the following program and its call stack on the right.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-5/call-stack.png&#34; alt=&#34;Call Stack&#34;&gt;&lt;/p&gt;
&lt;p&gt;The call stack consists of &lt;a href=&#34;https://en.wikipedia.org/wiki/Call_stack#Structure&#34;&gt;Stack Frames&lt;/a&gt;. Whenever a function is called, a new stack frame is created and &lt;code&gt;push&lt;/code&gt;ed onto the stack. When the called function returns - the stack frame is &lt;code&gt;pop&lt;/code&gt;ed.&lt;/p&gt;
&lt;p&gt;At every point, the call stack represents the actual &lt;a href=&#34;https://en.wikipedia.org/wiki/Stack_trace&#34;&gt;Stack Trace&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The very top of the call stack represents the scope of the whole file, followed by the stack frame of the &lt;code&gt;first&lt;/code&gt; function, followed by the &lt;code&gt;second&lt;/code&gt; function, and so forth.
In Ruby, the top function/file scope is referred to as simply &lt;code&gt;top&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, imagine that we want to pass some information from the &lt;code&gt;second&lt;/code&gt; function to the &lt;code&gt;top&lt;/code&gt;. Some error or something &lt;em&gt;exceptional&lt;/em&gt; happened, and this specific program state needs some special handling.&lt;/p&gt;
&lt;p&gt;There are several limited ways to handle such case: either return some special value up (thus, each function on the call stack should be aware of this), or we can use some global variable to communicate with the callers (e.g., &lt;code&gt;errno&lt;/code&gt; in C) which is again &amp;ldquo;pollutes&amp;rdquo; the business logic through the call stack.&lt;/p&gt;
&lt;p&gt;One way to handle this problem more elegantly is to use particular language constructs - exceptions.&lt;/p&gt;
&lt;p&gt;Instead of polluting the whole call stack, we can &lt;code&gt;throw&lt;/code&gt;/&lt;code&gt;raise&lt;/code&gt; an exception and then add special handling at the &lt;code&gt;top&lt;/code&gt;, like in this picture:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-5/exception-example.png&#34; alt=&#34;Simple Exception&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;stack-unwinding&#34;&gt;Stack Unwinding&lt;/h3&gt;
&lt;p&gt;Now, the question is: How do we implement this feature? To answer it, let&amp;rsquo;s understand what needs to happen!&lt;/p&gt;
&lt;p&gt;The program was in some specific state before it called the &lt;code&gt;first&lt;/code&gt; function at the top.
Now, the program is in another specific state around the &lt;code&gt;raise &amp;quot;error&amp;quot;&lt;/code&gt; line in the &lt;code&gt;second&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;We need to restore the state somehow as it was right before the &lt;code&gt;first&lt;/code&gt; call and continue execution right after the &lt;code&gt;rescue&lt;/code&gt; in &lt;code&gt;top&lt;/code&gt; (by changing the program counter accordingly).&lt;/p&gt;
&lt;p&gt;Conceptually, we can save the machine state before calling the &lt;code&gt;first&lt;/code&gt; method and restoring it later. The problem is that storing the state of the whole machine is too expensive and adds overhead by saving more than needed.&lt;/p&gt;
&lt;p&gt;Instead, we can put the responsibility for maintaining the program on the actual program developers.&lt;/p&gt;
&lt;p&gt;Most languages provide useful features for dealing with this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ruby has explicit &lt;code&gt;ensure&lt;/code&gt; blocks&lt;/li&gt;
&lt;li&gt;Java has explicit &lt;code&gt;finally&lt;/code&gt; statements&lt;/li&gt;
&lt;li&gt;C++ has RAII and implicit destructors&lt;/li&gt;
&lt;li&gt;(C has &lt;code&gt;setjmp&lt;/code&gt;/&lt;code&gt;longjmp&lt;/code&gt;, but we are only talking about useful features)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here is how it works in the case of Ruby.&lt;/p&gt;
&lt;p&gt;Whenever the exception is thrown, the program climbs up through the call stack and executes code from those &lt;a href=&#34;https://en.wikipedia.org/wiki/Finalizer#Connection_with_finally&#34;&gt;finalizers&lt;/a&gt;until it reaches the exception handler.&lt;/p&gt;
&lt;p&gt;This process is called &lt;code&gt;Stack Unwinding&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;I&amp;rsquo;m not a native speaker, but I&amp;rsquo;d say it should be called &amp;ldquo;Stack Winding&amp;rdquo;, but oh well&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Here is an updated example with explicit state restoration during the stack unwinding.&lt;/p&gt;
&lt;p&gt;Without executing code from the &lt;code&gt;ensure&lt;/code&gt; block, the hypothetical lock would never be released, thus breaking the program in terrible ways.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-5/stack-unwinding.png&#34; alt=&#34;Stack Unwinding&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;exceptions-in-ruby&#34;&gt;Exceptions in Ruby&lt;/h3&gt;
&lt;p&gt;Now, I can talk about different kinds of exceptions in Ruby.
From my perspective, there are three different kinds:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;actual &lt;code&gt;raise&lt;/code&gt;d exceptions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; statements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt; statements&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; statements have special meaning when used in the context of &lt;code&gt;Proc&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;Let me elaborate on all the three with the examples.&lt;/p&gt;
&lt;h4 id=&#34;normal-exceptions&#34;&gt;Normal Exceptions&lt;/h4&gt;
&lt;p&gt;Actual exceptions climb up the stack, calling finalizers until an exception handler is found.&lt;/p&gt;
&lt;p&gt;These are the normal exceptions you are all familiar with.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-5/exception-example.png&#34; alt=&#34;Simple Exception&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;returns-from-a-block&#34;&gt;&lt;code&gt;return&lt;/code&gt;s from a block&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;return&lt;/code&gt; statements behave differently depending on the lexical scope they are part of.&lt;/p&gt;
&lt;p&gt;Here is a little puzzle for you.&lt;/p&gt;
&lt;p&gt;What will be printed on the screen:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-5/return_blk-puzzle.png&#34; alt=&#34;Return from a block puzzle&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;return&lt;/code&gt; is called from within a block. You may expect the &lt;code&gt;x * 4&lt;/code&gt; to be returned from the block, but it&amp;rsquo;s returned from the enclosing function (lexical scope).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-5/return_blk-example.png&#34; alt=&#34;Return from a block call stack&#34;&gt;&lt;/p&gt;
&lt;p&gt;As you can see, &lt;code&gt;return x * 4&lt;/code&gt; would return from &lt;code&gt;f&lt;/code&gt; instead of from the block.&lt;/p&gt;
&lt;p&gt;The code prints&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2: 8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;instead of&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1: 8
2: 42
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;breaks&#34;&gt;&lt;code&gt;break&lt;/code&gt;s&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;Almost&lt;/em&gt; like &lt;code&gt;return&lt;/code&gt;s, &lt;code&gt;break&lt;/code&gt;s allow returning from the enclosing function, but in a slightly different way.&lt;/p&gt;
&lt;p&gt;This is the most complex example here. Let me write down the steps explicitly.
You may want to open the picture in a separate tab to read it.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-5/break-example.png&#34; alt=&#34;Break example&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;top&lt;/code&gt; calls the &lt;code&gt;loop&lt;/code&gt; function and passes the block to it. The block is just another function under the hood; it&amp;rsquo;s presented separately here as the &lt;code&gt;__anonymous_block.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Runtime creates a new stack frame for &lt;code&gt;loop&lt;/code&gt; and puts it on the call stack.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loop&lt;/code&gt; calls the passed block (&lt;code&gt;__anonymous_block&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Runtime creates new stack frame for &lt;code&gt;__anonymous_block&lt;/code&gt; and puts it on the stack.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;__anonymous_block&lt;/code&gt; increments &lt;code&gt;i&lt;/code&gt;, checks for equality, and returns to &lt;code&gt;loop&lt;/code&gt;, nothing special.&lt;/li&gt;
&lt;li&gt;Runtime removes the &lt;code&gt;__anonymous_block&lt;/code&gt; stack frame from the call stack.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loop&lt;/code&gt;s stack frame is kept on the call stack, and the next iteration of &lt;code&gt;while true&lt;/code&gt; calls the &lt;code&gt;__anonymous_block&lt;/code&gt; again.&lt;/li&gt;
&lt;li&gt;Runtime creates new stack frame for &lt;code&gt;__anonymous_block&lt;/code&gt; and puts it on the stack.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;__anonymous_block&lt;/code&gt; increments &lt;code&gt;i&lt;/code&gt;, checks for equality, and invokes &lt;code&gt;break&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;break&lt;/code&gt; initiates stack unwinding and returns from the enclosing function (&lt;code&gt;loop&lt;/code&gt;). See the dashed line.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loop&lt;/code&gt; returns, thus bypassing the endless loop &lt;code&gt;while true&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The &lt;code&gt;break&lt;/code&gt; construct is effectively equivalent to the following code:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-5/break-exception.png&#34; alt=&#34;Break implemented using exception&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;implementation&#34;&gt;Implementation&lt;/h3&gt;
&lt;p&gt;All the language constructs described above (exceptions, &lt;code&gt;return&lt;/code&gt;s and &lt;code&gt;break&lt;/code&gt;s within a block) behave similarly: they unwind the stack (calling the finalizers on the way up) and stop at some well-defined point.&lt;/p&gt;
&lt;p&gt;They are implemented slightly differently in the original mruby runtime. Still, I implemented them all as exceptions, with &lt;code&gt;return&lt;/code&gt;s and &lt;code&gt;break&lt;/code&gt;s being special exceptions: they need to carry a value and store information on where to stop the unwinding process.&lt;/p&gt;
&lt;p&gt;The implementation from the LLVM perspective is covered in my recent talk at LLVM Social Berlin: &lt;a href=&#34;https://www.youtube.com/watch?v=gH5-lITYrMg&#34;&gt;Stack unwinding, landing pads, and other catches&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here, I&amp;rsquo;ll mainly focus on the details from the Mruby runtime perspective.&lt;/p&gt;
&lt;p&gt;Consider the following example:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-5/landing-pads.png&#34; alt=&#34;Landing pads&#34;&gt;&lt;/p&gt;
&lt;p&gt;The blocks following &lt;code&gt;rescue&lt;/code&gt; and &lt;code&gt;ensure&lt;/code&gt; are called &lt;em&gt;&lt;strong&gt;Landing Pads&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;This example has two kinds of landing pads: catch (&lt;code&gt;rescue&lt;/code&gt;) and cleanup (&lt;code&gt;ensure&lt;/code&gt;).
Catches are &amp;ldquo;conditional&amp;rdquo; landing pads: they will be executed only if the exception type matches their type. Note the last &lt;code&gt;rescue&lt;/code&gt;: it doesn&amp;rsquo;t have any type attached, so it will just catch any exception.&lt;/p&gt;
&lt;p&gt;Conversely, cleanups are &amp;ldquo;unconditional&amp;rdquo; - they will always run, but they will also forward the exception up to the next function on the call stack.&lt;/p&gt;
&lt;p&gt;Another important detail in this example is the second &lt;code&gt;rescue&lt;/code&gt;: it uses function argument as its type. That is, the landing pad type is only known at run time, and it could be anything.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In C++, for example, all the &lt;code&gt;catch&lt;/code&gt; types must be known upfront, and the compiler emits special Runtime Type Information (RTTI). Again, IMO, it should be Compile Time Type Information, but it&amp;rsquo;s C++&amp;hellip;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;For this reason, Ruby VM always enters each landing pad. For catches, it first checks (at run time!) if the exception type matches the landing pad&amp;rsquo;s type, and if so, the exception is marked as caught, and the landing pad&amp;rsquo;s execution continues.&lt;/p&gt;
&lt;p&gt;If the exception type doesn&amp;rsquo;t match - the exception is immediately re-thrown so the next landing pad can try to catch it.&lt;/p&gt;
&lt;h3 id=&#34;mlir&#34;&gt;MLIR&lt;/h3&gt;
&lt;p&gt;I&amp;rsquo;d love to describe how I modeled exceptions at the MLIR level, but it will take more time to do it for several reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;my original approach to constructing SSA right away didn&amp;rsquo;t work due to the way exceptions work (namely, some registers must spill on the stack), so the dialects have changed a bit, and I need to clean them up a bit&lt;/li&gt;
&lt;li&gt;the way I model them currently is more of a hack and only works because I have certain conventions, so it&amp;rsquo;s not a solid model yet&lt;/li&gt;
&lt;li&gt;I added JIT support (for &lt;code&gt;Kernel.eval&lt;/code&gt;) and need to do some tweaking there to make exceptions work during just-in-time evaluation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;rsquo;ll write down all the low-level details at some point, but I don&amp;rsquo;t have an ETA, so I&amp;rsquo;ll stop here.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Thank you so much for reaching this far!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The following articles will focus on JIT compilation and debug information.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://lowlevelbits.org/subscribe/&#34;&gt;Don&amp;rsquo;t miss those details!&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
      

    

      
        <item>
        <title>Compiling Ruby. Part 4: progress update</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-4/</link>
        <pubDate>Thu, 30 Nov 2023</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-4/</guid>
        <description>&lt;p&gt;It&amp;rsquo;s been a while since I wrote the last blog post. One of the reasons is that so far, I had to change a lot of things in the implementation due to the exception support.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m writing a short progress update on where we are and what&amp;rsquo;s coming next.&lt;/p&gt;
&lt;h3 id=&#34;what-happened&#34;&gt;What Happened&lt;/h3&gt;
&lt;p&gt;During this year, I gave two short talks related to this project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=NfMX-dFMSr0&#34;&gt;a high-level overview of the project&lt;/a&gt; (EuroLLVM dev meeting)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=gH5-lITYrMg&#34;&gt;intro into exception handling in LLVM&lt;/a&gt; (LLVM Social Berlin)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The state as of EuroLLVM (May 2023) was as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;compiler supported &lt;strong&gt;104&lt;/strong&gt; out of &lt;strong&gt;107&lt;/strong&gt; bytecode operations&lt;/li&gt;
&lt;li&gt;it could compile &lt;strong&gt;~150&lt;/strong&gt; out of &lt;strong&gt;~180&lt;/strong&gt; files&lt;/li&gt;
&lt;li&gt;it could compile &lt;strong&gt;~15KLoC&lt;/strong&gt; out of &lt;strong&gt;~20KLOC&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;~72%&lt;/strong&gt; of tests were passing (1033 out of 1416 it could compile)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;current-status&#34;&gt;Current Status&lt;/h3&gt;
&lt;p&gt;The three missing opcodes were all about exception handling, and this is what (so far) took the most time to implement. I have some drafts on the details, and I plan to publish them before the end of the year.&lt;/p&gt;
&lt;p&gt;With the proper exception handling in place, things are finally starting to take the right shape.
There is still much work to do, but it&amp;rsquo;s more predictable now.&lt;/p&gt;
&lt;p&gt;Some new stats:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;all bytecode operations are implemented ðŸŽ‰&lt;/li&gt;
&lt;li&gt;all the ruby code in the repo is now compiled (stdlib, gems, tests) ðŸŽ‰&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;~95%&lt;/strong&gt; of the tests are passing (1378 out of 1450) ðŸŽ‰&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h3&gt;
&lt;p&gt;The test suite now drives the next steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the majority of the failing tests (42 out of 71) are due to the missing fibers implementation&lt;/li&gt;
&lt;li&gt;the second biggest group is various proc/methods metadata for runtime reflection&lt;/li&gt;
&lt;li&gt;the next big part is related to JIT/runtime evaluation (i.e., when you can execute arbitrary Ruby code not known/visible at compile time)&lt;/li&gt;
&lt;li&gt;and there is a long tail of more minor things&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Besides that, I need to figure out a better build system for all of it. Currently, It&amp;rsquo;s a mess glued together by CMake scripts and CMake templates. It works perfectly for development and testing, but I&amp;rsquo;d hate to use such a system as an end user.&lt;/p&gt;
&lt;p&gt;Ideally, I want a one-click solution that would take Ruby files as input and produce a native executable.&lt;/p&gt;
&lt;p&gt;What is the state of the art when it comes to build systems/orchestration of compilation? Please let me know if you have any pointers ðŸ™Œ&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Thank you so much for reaching this far!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The next article is about exceptions - &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-5/&#34;&gt;Exceptions&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
      

    

      
        <item>
        <title>Compiling Ruby. Part 3: MLIR and compilation</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-3/</link>
        <pubDate>Fri, 06 Jan 2023</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-3/</guid>
        <description>&lt;p&gt;Now as we have a decent understanding of how RiteVM works, we can tackle the compilation.
The question I had around two years ago - how do I even do this?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A note of warning: so far, this is the longest article on this blog. And I&amp;rsquo;m afraid the most cryptic one.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The topics covered here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MLIR&lt;/li&gt;
&lt;li&gt;Control-Flow Graphs (CFG)&lt;/li&gt;
&lt;li&gt;Static Single Assignment (SSA)&lt;/li&gt;
&lt;li&gt;Dataflow Analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;compilation&#34;&gt;Compilation&lt;/h3&gt;
&lt;p&gt;mruby is written in C, so the logic behind each opcode is implemented in C. To compile a Ruby program from bytecode, we can emit an equivalent C program that uses mruby C API.&lt;/p&gt;
&lt;p&gt;Some opcodes have direct API counterparts, e.g., &lt;code&gt;OP_LOADI&lt;/code&gt; is equivalent to &lt;code&gt;mrb_value mrb_fixnum_value(mrb_int i);&lt;/code&gt;. Yet, most opcodes are inlined in the giant dispatch loop in &lt;code&gt;vm.c&lt;/code&gt;. However, we can extract these implementations into separate functions and call them from C.&lt;/p&gt;
&lt;p&gt;Consider the following Ruby program:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;puts &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;and its bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADSELF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_SEND&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;  :&lt;span style=&#34;color:#66d9ef&#34;&gt;puts&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_RETURN&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_STOP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;An equivalent C program looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mrb_state &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;mrb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mrb_open&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mrb_value receiver &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fs_load_self&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mrb_value number &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mrb_fixnum_value&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mrb_funcall&lt;/span&gt;(mrb, receiver, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;puts&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;number);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mrb_close&lt;/span&gt;(mrb);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;code&gt;fs_load_self&lt;/code&gt; is a custom runtime function as &lt;code&gt;OP_LOADSELF&lt;/code&gt; doesn&amp;rsquo;t have a C API counterpart.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;OP_RETURN&lt;/code&gt; is ignored in this small example.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;To compile a Ruby program from its bytecode, we &amp;ldquo;just&amp;rdquo; need to generate the equivalent C program. In fact, this is what I did to start two years ago.
It worked well and had some nice debugging capabilities - in the end, it&amp;rsquo;s just a C program.&lt;/p&gt;
&lt;p&gt;Yet, at some point, the implementation became daunting. As I was generating a C program, it was pretty hard to do some custom analysis or optimizations on the C code. I started adding my auxiliary data structures (really, just arrays of hashmaps of hashmaps of pairs and tuples) before I generated the C code.&lt;/p&gt;
&lt;p&gt;I realized I was about to invent my intermediate representation of questionable quality.&lt;/p&gt;
&lt;p&gt;I needed a better solution.&lt;/p&gt;
&lt;h3 id=&#34;mlir&#34;&gt;MLIR&lt;/h3&gt;
&lt;p&gt;I remember watching the &lt;a href=&#34;https://www.youtube.com/watch?v=qzljG6DKgic&#34;&gt;MLIR talk&lt;/a&gt; by Tatiana Shpeisman and Chris Lattner live at EuroLLVM in Brussels. It went over my head back then, as there was a lot of talk about machine learning, tensors, heterogeneous accelerators, and some other dark magic.&lt;/p&gt;
&lt;p&gt;Yet, I also remember some mentions of custom intermediate representations. So I decided to give it a try and dig into it more. It turned out to be great.&lt;/p&gt;
&lt;p&gt;One of the key features of MLIR is the ability to define custom intermediate representations called &lt;em&gt;dialects&lt;/em&gt;. MLIR provides an infrastructure to mix and match different dialects and run analyses or transformations against them. Further, the dialects can be lowered to machine code (e.g., for CPU or GPU).&lt;/p&gt;
&lt;p&gt;Here is a slide from my &lt;a href=&#34;https://www.youtube.com/watch?v=Cl5SgDxvZ8w&#34;&gt;LLVM Social talk&lt;/a&gt; to illustrate the idea:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-3/what-is-mlir.png&#34; alt=&#34;What is MLIR?&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mlir-rite-dialect&#34;&gt;MLIR Rite Dialect&lt;/h3&gt;
&lt;p&gt;I need to define a custom dialect to make MLIR work for my use case. I called it &amp;ldquo;Rite.&amp;rdquo; The dialect needs an operation of each RiteVM opcode and some RiteVM types.&lt;/p&gt;
&lt;p&gt;Here is the minimum required to compile the code sample from above (&lt;code&gt;puts 42&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Rite_Dialect&lt;/span&gt; : Dialect {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rite&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A one-to-one mapping from mruby RITE VM bytecode to MLIR&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let cppNamespace &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rite&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RiteType&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;string name&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; : TypeDef&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Rite_Dialect, name&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let mnemonic &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ValueType&lt;/span&gt; : RiteType&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StateType&lt;/span&gt; : RiteType&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;state&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Rite_Op&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;string mnemonic, list&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Trait&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; traits &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; :
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Rite_Dialect, mnemonic, traits&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; OPCODE(LOADSELF, B) &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; R(a) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadSelfOp&lt;/span&gt; : Rite_Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_LOADSELF&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_LOADSELF&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (outs ValueType);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; OPCODE(LOADI, BB) &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; R(a) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mrb_int(b) &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadIOp&lt;/span&gt; : Rite_Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_LOADI&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_LOADI&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let arguments &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ins SI64Attr:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (outs ValueType);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; OPCODE(SEND, BBB) &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; R(a) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; call(R(a),Syms(b),R(a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;),&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;,R(a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;c)) &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SendOp&lt;/span&gt; : Rite_Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_SEND&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_SEND&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let arguments &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ins ValueType:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;receiver, StringAttr:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;symbol, UI32Attr:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;argc, Variadic&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ValueType&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;argv);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (outs ValueType);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; OPCODE(RETURN, B) &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; R(a) (normal) &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReturnOp&lt;/span&gt; : Rite_Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_RETURN&amp;#34;&lt;/span&gt;, [Terminator]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_RETURN&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let arguments &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ins ValueType:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;src);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (outs ValueType);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It defines the dialect, the types needed, and the operations.
Some entities come from the MLIR&amp;rsquo;s predefined dialects (&lt;code&gt;StringAttr&lt;/code&gt;, &lt;code&gt;UI32Attr&lt;/code&gt;, &lt;code&gt;Variadic&amp;lt;...&amp;gt;&lt;/code&gt;, &lt;code&gt;Terminator&lt;/code&gt;). We define the rest.&lt;/p&gt;
&lt;p&gt;Each operation may take zero or more arguments, but it also may produce zero or more results. Unlike a &amp;ldquo;typical&amp;rdquo; programming language, MLIR dialects define a graph (as &lt;code&gt;ins&lt;/code&gt; and &lt;code&gt;outs&lt;/code&gt; hint at). The dialects also have some other properties, but one step at a time.&lt;/p&gt;
&lt;p&gt;With the dialect in place, I can generate an &amp;ldquo;MLIR program&amp;rdquo; which is roughly equivalent to the C program above:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: I omit some details for brevity.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;module &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;test.rb&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    %0 = rite.OP_LOADSELF() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    %1 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    %2 = rite.OP_SEND(%0, %1) {argc = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; : ui32, symbol = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;puts&amp;#34;&lt;/span&gt;} : (!rite.value, !rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    %3 = rite.OP_RETURN(%2) : (!rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here, I generated an MLIR module containing a function (&lt;code&gt;top&lt;/code&gt;) with four operations corresponding to each bytecode operation.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a detailed look at one operation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;%2 = rite.OP_SEND(%0, %1) {argc = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; : ui32, symbol = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;puts&amp;#34;&lt;/span&gt;} : (!rite.value, !rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This piece defines a value named &lt;code&gt;%2&lt;/code&gt;, which takes two other values (&lt;code&gt;%0&lt;/code&gt; and &lt;code&gt;%1&lt;/code&gt;). In MLIR, constants are defined as &amp;ldquo;attributes,&amp;rdquo; which are &lt;code&gt;argc = 1 : ui32&lt;/code&gt; and &lt;code&gt;symbol = &amp;quot;puts&amp;quot;&lt;/code&gt; in this case. What follows is the operation signature &lt;code&gt;(!rite.value, !rite.value) -&amp;gt; !rite.value&lt;/code&gt;. The operation returns &lt;code&gt;rite.value&lt;/code&gt; and takes several arguments: &lt;code&gt;%0&lt;/code&gt; is the receiver, and &lt;code&gt;%1&lt;/code&gt; is part of the &lt;code&gt;Variadic&amp;lt;ValueType&amp;gt;:$argv&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;MLIR takes the declarative dialect definition and generates C++ code out of it. The C++ code serves as a programmatic API to generate the MLIR module.&lt;/p&gt;
&lt;p&gt;Once the module is generated, I can analyze and transform it. The next step is directly converting the Rite Dialect into LLVM Dialect and lowering it into LLVM IR.&lt;/p&gt;
&lt;p&gt;From there on, I can emit an object file (machine code) and link it with mruby runtime.&lt;/p&gt;
&lt;h3 id=&#34;static-single-assignment-ssa&#34;&gt;Static Single Assignment (SSA)&lt;/h3&gt;
&lt;p&gt;In the previous article, I mentioned that the virtual stack is essential, yet here in both C and MLIR programs, I use &amp;ldquo;local variables&amp;rdquo; instead of the stack. What&amp;rsquo;s going on here?&lt;/p&gt;
&lt;p&gt;The answer is simple - MLIR uses a Static Single-Assignment form for all its representations.&lt;/p&gt;
&lt;p&gt;As a reminder, SSA means that each variable can only be defined once.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Pedantic note: the &amp;ldquo;variables&amp;rdquo; should be referred to as &amp;ldquo;values&amp;rdquo; as they cannot vary.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Here is an &amp;ldquo;invalid&amp;rdquo; SSA form:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// redefinition not allowed in SSA
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(x);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And here is the same code in the SSA form:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;redefinition&amp;#34; generates a new value
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(x1);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We must convert the registers into SSA values to satisfy the MLIR requirement to be in SSA form.&lt;/p&gt;
&lt;p&gt;At first glance, the problem is trivial. We can maintain a map of definitions for each register at each point in time. For example, for the following bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADSELF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// #1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// #2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// #3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// #4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_ADD&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// #5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_RETURN&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// #6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The map changes as follows:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Step #1: { empty }
Step #2: {
  R1 defined by #1
}
Step #3: {
  R1 defined by #1
  R2 defined by #2
}
Step #4: {
  R1 defined by #1
  R2 defined by #2
  R3 defined by #3
}
Step #5: {
  R1 defined by #1
  R2 defined by #2
  R3 defined by #4 // R3 redefined at #4
}
Step #5: {
  R1 defined by #1
  R2 defined by #5 // OP_ADD stores the result in the first operand
  R3 defined by #4
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this map, we know precisely where a register was defined when an operation uses the register.&lt;/p&gt;
&lt;p&gt;So MLIR version will look like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_LOADSELF R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%0 = rite.OP_LOADSELF() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_LOADI    R2 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%1 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_LOADI    R3 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%2 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_LOADI    R3 30
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%3 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_ADD      R2 R3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%4 = rite.OP_ADD(%1, %3) : (!rite.value, !rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_RETURN   R2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%5 = rite.OP_RETURN(%4) : (!rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;Side note: &lt;code&gt;%0&lt;/code&gt; and &lt;code&gt;%2&lt;/code&gt; are never used and can be eliminated (if &lt;code&gt;OP_LOADSELF&lt;/code&gt;/&lt;code&gt;OP_LOADI&lt;/code&gt; don&amp;rsquo;t have side effects).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This solution is pleasant until the code has branching such as &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, loops, or exceptions.&lt;/p&gt;
&lt;p&gt;Consider the following non-SSA example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (something) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(x); &lt;span style=&#34;color:#75715e&#34;&gt;// Where x is defined?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Classical SSA solves this problem with artificial &lt;code&gt;phi&lt;/code&gt;-nodes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (something) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;phi&lt;/span&gt;(x2, x3); &lt;span style=&#34;color:#75715e&#34;&gt;// Will magically resolve to the right x depending on where it comes from
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(x4);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;MLIR approaches this differently and elegantly - via &amp;ldquo;block arguments.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;But first, let&amp;rsquo;s talk about Control-Flow Graphs.&lt;/p&gt;
&lt;h3 id=&#34;control-flow-graph-cfg&#34;&gt;Control-Flow Graph (CFG)&lt;/h3&gt;
&lt;p&gt;A control-flow graph is a form of intermediate representation that maintains the program in the form of a graph where operations are connected to each other based on the execution (or control) flow.&lt;/p&gt;
&lt;p&gt;Consider the following bytecode (the number on the left is an operation address):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;001:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// puts &amp;#34;true&amp;#34; in R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;002:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;003:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMPIF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// jump to 006 if R1 contains &amp;#34;true&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                      &lt;span style=&#34;color:#75715e&#34;&gt;// otherwise implicitly falls through to 004
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;004:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;005:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMP&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;// jump to 007 unconditionally
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;006:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;007:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_ADD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// R3 may be either 20 or 30, depending on the branching
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The same program in the form of a graph:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-3/naive-cfg.png&#34; alt=&#34;CFG without basic blocks&#34;&gt;&lt;/p&gt;
&lt;p&gt;This CFG can be further optimized: we can merge all the subsequent nodes unless the node has more than one incoming or more than one outgoing edge.&lt;/p&gt;
&lt;p&gt;The merged nodes are called basic blocks:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-3/complete-cfg.png&#34; alt=&#34;CFG with basic blocks&#34;&gt;&lt;/p&gt;
&lt;p&gt;Some more terms for completeness:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &amp;ldquo;first&amp;rdquo; basic block where the execution of a function starts is called &amp;ldquo;entry.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;similarly, the &amp;ldquo;last&amp;rdquo; basic block is called &amp;ldquo;exit.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;preceding (incoming, previous) basic blocks are called predecessors. The entry block doesn&amp;rsquo;t have predecessors.&lt;/li&gt;
&lt;li&gt;succeeding (outgoing, next) basic blocks are called successors. Exit blocks don&amp;rsquo;t have successors.&lt;/li&gt;
&lt;li&gt;the last operation in a basic block is called a terminator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on the last picture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B1&lt;/code&gt;: entry block&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B4&lt;/code&gt;: single exit block. There could be several exit blocks, yet we can always add one &amp;ldquo;empty&amp;rdquo; block as a successor for the exit blocks to have only one exit block.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B1&lt;/code&gt;: predecessors: [], successors: [&lt;code&gt;B2&lt;/code&gt;, &lt;code&gt;B3&lt;/code&gt;], terminator: &lt;code&gt;OP_JMPIF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B2&lt;/code&gt;: predecessors: [&lt;code&gt;B1&lt;/code&gt;], successors: [&lt;code&gt;B4&lt;/code&gt;], terminator: &lt;code&gt;OP_JMP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B3&lt;/code&gt;: predecessors: [&lt;code&gt;B1&lt;/code&gt;], successors: [&lt;code&gt;B4&lt;/code&gt;], terminator: &lt;code&gt;OP_LOADI&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B4&lt;/code&gt;: predecessors: [&lt;code&gt;B2&lt;/code&gt;, &lt;code&gt;B3&lt;/code&gt;], successors: [], terminator: &lt;code&gt;OP_ADD&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cfgs-in-mlir&#34;&gt;CFGs in MLIR&lt;/h3&gt;
&lt;p&gt;Now we can take a look at CFGs from the MLIR perspective. If you are familiar with CFGs in LLVM, then the important difference is that in MLIR, all the basic blocks may have arguments. Function arguments are, in fact, the block arguments from the entry block. For example, this is a more accurate representation of a function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;() -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb0(%arg0: !rite.state, %arg1: !rite.value):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %0 = rite.OP_LOADSELF() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %1 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %2 = rite.OP_SEND(%0, %1) {argc = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; : ui32, symbol = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;puts&amp;#34;&lt;/span&gt;} : (!rite.value, !rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %3 = rite.OP_RETURN(%2) : (!rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;Note, &lt;code&gt;^bbX&lt;/code&gt; represents the basic blocks.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;To convert the following bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;001:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// puts &amp;#34;true&amp;#34; in R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;002:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;003:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMPIF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// jump to 006 if R1 contains &amp;#34;true&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                      &lt;span style=&#34;color:#75715e&#34;&gt;// otherwise implicitly falls through to 004
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;004:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;005:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMP&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;// jump to 007 unconditionally
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;006:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;007:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_ADD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// R3 may be either 20 or 30, depending on the branching
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;we need to take several steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add an address attribute to all addressable operations (they could be jump targets)&lt;/li&gt;
&lt;li&gt;add &amp;ldquo;targets&amp;rdquo; attribute to all the jumps, including implicit fallthrough jumps&lt;/li&gt;
&lt;li&gt;add an explicit jump in place of the implicit jumps&lt;/li&gt;
&lt;li&gt;add the successor blocks for all jump instructions&lt;/li&gt;
&lt;li&gt;put all the operations in a single, entry basic block&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %1 = rite.OP_LOADT() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;001&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %2 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;002&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.OP_JMPIF(%0)[^bb1, ^bb1] { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;003&lt;/span&gt;, targets = [&lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;004&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %3 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;004&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.OP_JMP()[^bb1] { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;005&lt;/span&gt;, targets = [&lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %4 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.FallthroughJump()[^bb1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %5 = rite.OP_ADD(%0, %0) { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;Note: I&amp;rsquo;m omitting some details from the textual representation for brevity.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Notice, here, I added a &amp;ldquo;phony value&amp;rdquo; as a placeholder for SSA values as we cannot yet construct the proper SSA. We will remove them in the next section.&lt;/p&gt;
&lt;p&gt;Additionally, I added a phony basic block to serve as a placeholder successor for the jump targets.&lt;/p&gt;
&lt;p&gt;Now, the last steps are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;split the entry basic block by cutting it right before each jump target operation&lt;/li&gt;
&lt;li&gt;rewire the jumps to point to the right target basic blocks&lt;/li&gt;
&lt;li&gt;delete the phony basic block used as a placeholder&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The final CFG looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %1 = rite.OP_LOADT() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;001&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %2 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;002&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.OP_JMPIF(%0)[^bb1, ^bb2] { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;003&lt;/span&gt;, targets = [&lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;004&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;004&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.OP_JMP()[^bb3] { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;005&lt;/span&gt;, targets = [&lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.FallthroughJump()[^bb3]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%0, %0) { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It corresponds to the last picture above, except that we now have an explicit &lt;code&gt;rite.FallthroughJump()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With the CFG in place, we can solve the SSA problem and eliminate the &lt;code&gt;rite.PhonyValue()&lt;/code&gt; placeholder.&lt;/p&gt;
&lt;h3 id=&#34;ssa-in-mlir&#34;&gt;SSA in MLIR&lt;/h3&gt;
&lt;p&gt;As a reminder, here is the CFG of the &amp;ldquo;problematic&amp;rdquo; program:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-3/complete-cfg.png&#34; alt=&#34;CFG with basic blocks&#34;&gt;&lt;/p&gt;
&lt;p&gt;In the MLIR form, we no longer have registers from the virtual stack. We only have values such as &lt;code&gt;%2&lt;/code&gt;, &lt;code&gt;%3&lt;/code&gt;, &lt;code&gt;%4&lt;/code&gt;, and so on. The tricky part is the &lt;code&gt;007: OP_ADD R2 R3&lt;/code&gt; operation - where &lt;code&gt;R3&lt;/code&gt; is coming from? Is it &lt;code&gt;%3&lt;/code&gt; or &lt;code&gt;%4&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;To answer this question, we can use &lt;a href=&#34;https://en.wikipedia.org/wiki/Data-flow_analysis&#34;&gt;Data-flow analysis&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Dataflow analysis is used to derive specific facts about the program. The analysis is an iterative process: first, collect the base facts for each basic block, then for each basic block, update the facts combining them with the facts from successors or predecessors. As the facts updated for a basic block may affect the facts from successors/predecessors, the process should run iteratively until no new facts are derived.&lt;/p&gt;
&lt;p&gt;A critical requirement for the facts - they should be monotonic. Once the fact is known, it cannot &amp;ldquo;disappear.&amp;rdquo; This way, the iterative process eventually stops as, in the worst case, the analysis will derive &amp;ldquo;all&amp;rdquo; the facts about the program and won&amp;rsquo;t be able to derive any more.&lt;/p&gt;
&lt;p&gt;My favorite resource about dataflow analysis is Adrian Sampson&amp;rsquo;s lectures on the subject - &lt;a href=&#34;https://www.cs.cornell.edu/courses/cs6120/2020fa/lesson/4/&#34;&gt;The Data Flow Framework&lt;/a&gt;. I highly recommend it.&lt;/p&gt;
&lt;p&gt;In our case, the facts we need to derive are: which values/registers are required for each operation.&lt;/p&gt;
&lt;p&gt;Here is an algorithm briefly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;at every point in time, there is a map of the values defined so far&lt;/li&gt;
&lt;li&gt;if an operation is using a value that is not defined, then this value is &lt;code&gt;required&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the required values become the block arguments and must be coming from the predecessors&lt;/li&gt;
&lt;li&gt;the terminators of the &amp;ldquo;required&amp;rdquo; predecessors now use the values required by the successors&lt;/li&gt;
&lt;li&gt;at the next iteration, the block arguments define the previously required values&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The process runs iteratively until no new required values appear.&lt;/p&gt;
&lt;p&gt;An important detail for the entry basic block is that, as it doesn&amp;rsquo;t have a predecessor, all the required values must come from the virtual stack.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look a the example bytecode once again:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;001:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;002:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;003:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMPIF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;004:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;005:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMP&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;006:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;007:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_ADD&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is the initial state for the dataflow analysis. The comments above contain information about defined values for the given point in time. Comment on the side of each operation tells about the operation itself:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %1 = rite.OP_LOADT() : () -&amp;gt; !rite.value     &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R1], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %2 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1, R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMPIF(%0)[^bb1, ^bb2]                &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                            // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMP()[^bb3]                          &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                            // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.FallthroughJump()[^bb3]                 &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2                      // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%0, %0) : () -&amp;gt; !rite.value &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The last operation uses values that are not defined. Therefore &lt;code&gt;R2&lt;/code&gt; and &lt;code&gt;R3&lt;/code&gt; are required and must come from the predecessors.&lt;/p&gt;
&lt;p&gt;Update predecessors and rerun the analysis.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: I am using %RX_Y names to distinguish them from the original numerical value names. X is the register number, and Y is the basic block number.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %1 = rite.OP_LOADT() : () -&amp;gt; !rite.value     &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R1], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %2 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1, R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMPIF(%0)[^bb1, ^bb2]                &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                            // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMP(%0, %0)[^bb3]                    &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                            // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.FallthroughJump(%0, %0)[^bb3]           &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3(%R2_3, %R3_3): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2        // defines: [R2, R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%0, %0) : () -&amp;gt; !rite.value &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Basic block &lt;code&gt;^bb3&lt;/code&gt; now has two block arguments.
The terminators from its predecessors (&lt;code&gt;^bb1&lt;/code&gt; and &lt;code&gt;^bb2&lt;/code&gt;) now use an undefined value, &lt;code&gt;R2&lt;/code&gt;. &lt;code&gt;R2&lt;/code&gt; is now required. We must add it as a block argument and propagate it to the predecessors&amp;rsquo; terminators.&lt;/p&gt;
&lt;p&gt;Rerun the analysis:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %1 = rite.OP_LOADT() : () -&amp;gt; !rite.value     &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R1], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %2 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1, R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMPIF(%0, %0, %0)[^bb1, ^bb2]        &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R1, R2, R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1(%R2_1): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                     // defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMP(%0, %0)[^bb3]                    &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2(%R2_2): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                     // defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.FallthroughJump(%0, %0)[^bb3]           &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3(%R2_3, %R3_3): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2        // defines: [R2, R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%0, %0) : () -&amp;gt; !rite.value &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can run the analysis one more time, but it won&amp;rsquo;t change anything, so that would conclude the analysis, and we should have all the information we need to replace the phony value with the correct values.&lt;/p&gt;
&lt;p&gt;Additionally, now we can replace our custom jump operations with the builtin ones from MLIR, so the final function looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %1 = rite.OP_LOADT() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %2 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;) : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cond_br %1, ^bb1(%2), ^bb2(%2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1(%R2_1): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  br ^bb3(%R2_1, %3)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2(%R2_2): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  br ^bb3(%R2_2, %4)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3(%R2_3, %R3_3): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%R2_3, %R3_3) : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now, onto drawing the rest of the fu**ing owl.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Thank you so much for reaching this far!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The next article gives a short &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-4/&#34;&gt;progress update&lt;/a&gt;.&lt;/p&gt;
</description>
      </item>
      

    

      
        <item>
        <title>Compiling Ruby. Part 2: RiteVM</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-2/</link>
        <pubDate>Wed, 04 Jan 2023</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-2/</guid>
        <description>&lt;p&gt;mruby (so-called &amp;ldquo;embedded&amp;rdquo; Ruby) is a relatively small Ruby implementation.&lt;/p&gt;
&lt;p&gt;mruby is based on a register-based virtual machine. In the previous article, I mentioned the difference between stack- and register-based VMs, but what is a Virtual Machine?
As obvious as it gets, a Virtual Machine is a piece of software that mimics specific behavior(s) of a Real Machine.&lt;/p&gt;
&lt;p&gt;Depending on the kind of virtual machine, the capabilities may vary.
A VM can mimic a typical computer&amp;rsquo;s complete behavior, allowing us to run any software we&amp;rsquo;d run on a regular machine (think VirtualBox or VMware).
Or it can implement a behavior of an imaginary, artificial machine that doesn&amp;rsquo;t have a counterpart in the real physical world (think JVM or CLR).&lt;/p&gt;
&lt;p&gt;The mruby RiteVM is of a latter kind. It defines a set of &amp;ldquo;CPU&amp;rdquo; operations and provides a runtime to run them. The operations are referred to as bytecode. The bytecode consists of an operation kind (opcode) and its corresponding metadata (registers, flags, etc.).&lt;/p&gt;
&lt;h3 id=&#34;bytecode&#34;&gt;Bytecode&lt;/h3&gt;
&lt;p&gt;Here is a tiny snippet of various RiteVM operations (coming from &lt;code&gt;mruby/ops.h&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OPCODE&lt;/span&gt;(NOP,   Z)  &lt;span style=&#34;color:#75715e&#34;&gt;/* no operation */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OPCODE&lt;/span&gt;(MOVE,  BB) &lt;span style=&#34;color:#75715e&#34;&gt;/* R(a) = R(b) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OPCODE&lt;/span&gt;(ADD,   B)  &lt;span style=&#34;color:#75715e&#34;&gt;/* R(a) = R(a)+R(a+1) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OPCODE&lt;/span&gt;(ENTER, W)  &lt;span style=&#34;color:#75715e&#34;&gt;/* arg setup according to flags (23=m5:o5:r1:m5:k5:d1:b1) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OPCODE&lt;/span&gt;(JMP,   S)  &lt;span style=&#34;color:#75715e&#34;&gt;/* pc+=a */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;All the opcodes follow the same form:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OPCODE&lt;/span&gt;(name, operands) &lt;span style=&#34;color:#75715e&#34;&gt;/* comment */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;name&lt;/code&gt; is self-explanatory. The &lt;code&gt;comment&lt;/code&gt; describes (or hints at) an operation&amp;rsquo;s semantics.
The &lt;code&gt;operands&lt;/code&gt; is a bit more tricky and is directly related to the bytecode encoding.&lt;/p&gt;
&lt;p&gt;Each letter in the &lt;code&gt;operands&lt;/code&gt; describes the size of the operand. &lt;code&gt;Z&lt;/code&gt; means that the operand&amp;rsquo;s size is zero bytes (i.e., there is no operand).
&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;W&lt;/code&gt; all mean one operand, but their sizes are 1, 2, and 3 bytes, respectively.
These definitions can be mixed and matched as needed, but in practice, only the following combinations are used (from &lt;code&gt;mruby/ops.h&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* operand types:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; + BB: 8+8bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; + BBB: 8+8+8bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; + BS: 8+16bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; + BSS: 8+16+16bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;as the operation may have up to three operands max.&lt;/p&gt;
&lt;p&gt;The operands are called &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;. The following bytecode string will be decoded differently depending on the operand definition (the &lt;code&gt;42&lt;/code&gt; will be mapped to a corresponding opcode):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BBB&lt;/code&gt; -&amp;gt; &lt;code&gt;a = 1, b = 2, c = 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; -&amp;gt; &lt;code&gt;a = 1, b = undefined, c = undefined&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; is treated as the next opcode&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BS&lt;/code&gt; -&amp;gt; &lt;code&gt;a = 1, b = 2 &amp;lt;&amp;lt; 8 | 3, c = undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt; -&amp;gt; &lt;code&gt;a = 1 &amp;lt;&amp;lt; 16 | 2 &amp;lt;&amp;lt; 8 | 3, b = undefined, c = undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;and so on.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now the comments from the snippet above make more sense:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NOP&lt;/code&gt; does nothing with all its zero operands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MOVE&lt;/code&gt; copies value from register &lt;code&gt;b&lt;/code&gt; to register &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENTER&lt;/code&gt; maps the operand &lt;code&gt;a&lt;/code&gt; to the flags needed for its logic&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JMP&lt;/code&gt; changes the program counter to point to a new location &lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With all this information, we now understand &lt;em&gt;what&lt;/em&gt; the operations do.
The next question is &lt;em&gt;how&lt;/em&gt; do they do it?&lt;/p&gt;
&lt;h3 id=&#34;bytecode-execution&#34;&gt;Bytecode Execution&lt;/h3&gt;
&lt;p&gt;The bytecode doesn&amp;rsquo;t live in a vacuum. Each bytecode sequence is part of a method. Consider the following example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(a, b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;puts sum(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can look into its bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mruby&lt;/span&gt; --&lt;span style=&#34;color:#66d9ef&#34;&gt;verbose&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sum.rb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;skipped&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;irep&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x600001390000&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nregs&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nlocals&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;pools&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;syms&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reps&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ilen&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;file: &lt;span style=&#34;color:#a6e22e&#34;&gt;sum.rb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;000&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TCLASS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;002&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;METHOD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;I&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0x600001390050&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;005&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DEF&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;008&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LOADI&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;011&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LOADI&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;014&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SSEND&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x02&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;018&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SSEND&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;puts&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x01&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;022&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RETURN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;024&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;STOP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;irep&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x600001390050&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nregs&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nlocals&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;pools&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;syms&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reps&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ilen&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;variable&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;names&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; R1:&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; R2:&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; R3:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;amp;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;file: &lt;span style=&#34;color:#a6e22e&#34;&gt;sum.rb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;000&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ENTER&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x80000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;004&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MOVE&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;; R1:a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;007&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MOVE&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R5&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;; R2:b
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;010&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ADD&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;012&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RETURN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The bytecode sequence is part of the &lt;code&gt;mrb_irep&lt;/code&gt; struct, which is subsequently part of the &lt;code&gt;RProc&lt;/code&gt; struct, which corresponds to a Ruby method (procedure?) object.&lt;/p&gt;
&lt;p&gt;The distinction is necessary as &lt;code&gt;RProc&lt;/code&gt; is a higher-level abstraction over an executable code, which might be either a RiteVM bytecode or a C function. Additionally, there is a distinction between a &lt;code&gt;lambda&lt;/code&gt;, a &lt;code&gt;block&lt;/code&gt;, and a &lt;code&gt;method&lt;/code&gt;. Yet, we will only focus on the bytecode parts and ignore all the lambda/block/method shenanigans.&lt;/p&gt;
&lt;p&gt;In the &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-1/#ruby-and-its-many-virtual-machines&#34;&gt;previous article&lt;/a&gt;, I briefly described the dispatch loop and how a VM interacts with the virtual stack. The description is not precise but accurate and catches the essential details.&lt;/p&gt;
&lt;p&gt;Execution of each &lt;code&gt;RProc&lt;/code&gt; requires a virtual stack to operate on the data, but it also requires some additional metadata. The &amp;ldquo;metadata&amp;rdquo; is part of the so-called &lt;code&gt;mrb_callinfo&lt;/code&gt; struct. This concept is known as &lt;code&gt;stack frame&lt;/code&gt; or &lt;code&gt;activation record&lt;/code&gt;.
The virtual stack is stored separately but is part of the &lt;code&gt;mrb_callinfo&lt;/code&gt; (sort of).
The virtual stack is essential as it is the only way to communicate between different operations and different &lt;code&gt;RProc&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;Here is what happens during bytecode execution:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mrb_callinfo&lt;/code&gt; is created from an &lt;code&gt;RProc&lt;/code&gt; and is put onto the &amp;ldquo;call info&amp;rdquo; stack or simply a call stack. The new &lt;code&gt;mrb_callinfo&lt;/code&gt; points to a new location of the shared virtual stack (see the first picture below).&lt;/li&gt;
&lt;li&gt;Each operation in &lt;code&gt;RProc&lt;/code&gt;&amp;rsquo;s &lt;code&gt;mrb_irep&lt;/code&gt; is executed in the context of the top &lt;code&gt;mrb_callinfo&lt;/code&gt; on the call stack. The virtual stack and state of the VM are updated accordingly.&lt;/li&gt;
&lt;li&gt;When any &amp;ldquo;sendable&amp;rdquo; (&lt;code&gt;OP_SEND&lt;/code&gt;, &lt;code&gt;OP_SSEND&lt;/code&gt;, &lt;code&gt;OP_SENDBV&lt;/code&gt;, etc.) operation is encountered, we move to step 1.&lt;/li&gt;
&lt;li&gt;When any &amp;ldquo;returnable&amp;rdquo; (&lt;code&gt;OP_RETURN&lt;/code&gt;, &lt;code&gt;OP_RETURN_BLK&lt;/code&gt;) operation is encountered, then the operand is put into the &amp;ldquo;return register&amp;rdquo; (for consumption by the caller), and the call stack is popped, effectively removing &lt;code&gt;mrb_callinfo&lt;/code&gt; created at step 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here is how it looks in memory:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-2/bytecode-execution-high-level.png&#34; alt=&#34;Bytecode Execution Highlevel View&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mrb_state&lt;/code&gt; (the state of the whole VM) has a stack of &lt;code&gt;mrb_context&lt;/code&gt;s (more on them in a later article). Each &lt;code&gt;mrb_context&lt;/code&gt; maintains the stack of &lt;code&gt;mrb_callinfo&lt;/code&gt; (the call stack). Each &lt;code&gt;mrb_context&lt;/code&gt; owns a virtual stack, which is shared among several &lt;code&gt;mrb_callinfo&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This way, the caller prepares the stack for the callee.&lt;/p&gt;
&lt;p&gt;As a reminder, here is the bytecode from the example above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;top:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TCLASS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;METHOD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;I&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0x600001390050&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;DEF&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LOADI&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LOADI&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SSEND&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x02&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SSEND&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;puts&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x01&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;RETURN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;STOP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sum:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ENTER&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x80000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;MOVE&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;; R1:a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;MOVE&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R5&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;; R2:b
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ADD&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;RETURN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is how the shared stack looks from the perspective of both the top-level method &lt;code&gt;top&lt;/code&gt; and the method &lt;code&gt;sum&lt;/code&gt;: by the time the first &lt;code&gt;SSEND&lt;/code&gt; operand (&amp;ldquo;send to self&amp;rdquo;) is executed, all the values are ready for consumption by the callee.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-2/bytecode-execution.png&#34;
style=&#34; display: block;
margin-left: 0;
margin-right: auto;
width: 80%;
height: auto;&#34; /&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Hopefully, now you better understand how RiteVM uses bytecode, and we are one step closer to the actual fun part - compilation!&lt;/p&gt;
&lt;p&gt;The following article covers MLIR and the way I modeled dialects - &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-3/&#34;&gt;MLIR and compilation&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
      

    

      
        <item>
        <title>Compiling Ruby. Part 1: Compilers vs. Interpreters</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-1/</link>
        <pubDate>Fri, 02 Dec 2022</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-1/</guid>
        <description>&lt;p&gt;With the (hopefully) convincing &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-0&#34;&gt;motivation&lt;/a&gt; out of the way, we can get to the technical details.&lt;/p&gt;
&lt;h3 id=&#34;compiling-interpreter-interpreting-compiler&#34;&gt;Compiling Interpreter, Interpreting Compiler&lt;/h3&gt;
&lt;p&gt;As mentioned in the motivation, I want to build an ahead-of-time compiler for Ruby. I want it to be compatible with the existing Ruby implementation to fit it naturally into the existing system.&lt;/p&gt;
&lt;p&gt;So the first question I had to answer is - how do I even do it?&lt;/p&gt;
&lt;h4 id=&#34;compilers-vs-interpreters&#34;&gt;Compilers vs. Interpreters&lt;/h4&gt;
&lt;p&gt;The execution model of compiled and interpreted languages is slightly different:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a compiler takes the source program and outputs another program that can be run on any other machine even when the compiler is not on that target machine&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;an interpreter also takes the source program as an input but does not output anything and runs the program right away&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unlike the compiler, the interpreter must be present on the machine you want to run the program. To build the compiler, I have to somehow combine the interpreter with the program it runs.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a high-level schematic view of a typical compiler and interpreter.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-1/compiler-vs-interpreter.png&#34; alt=&#34;Execution model of an interpreted and compiled program&#34;&gt;&lt;/p&gt;
&lt;p&gt;The compiler is a straightforward one-way process: the source code is parsed, then the machine code is generated, and the executable is produced. The executable also depends on a runtime. The runtime can be either embedded into the executable or be an external entity, but usually both.&lt;/p&gt;
&lt;p&gt;The interpreter is more complex in this regard. It contains everything in one place: parser, runtime, and a virtual machine. Also, note the two-way arrows &lt;code&gt;Parser &amp;lt;-&amp;gt; VM&lt;/code&gt; and &lt;code&gt;Runtime &amp;lt;-&amp;gt; VM.&lt;/code&gt; The reason is that Ruby is a dynamic language. During the regular program execution, a program can read more code from the disk or network and execute it, thus the interconnection between these components.&lt;/p&gt;
&lt;h4 id=&#34;parser--vm--runtime&#34;&gt;Parser + VM + Runtime&lt;/h4&gt;
&lt;p&gt;Arguably, the triple &lt;code&gt;VM&lt;/code&gt; + &lt;code&gt;Parser&lt;/code&gt; + &lt;code&gt;Runtime&lt;/code&gt; can be called &amp;ldquo;a runtime,&amp;rdquo; but I prefer to have some separation of concerns. Here is where I draw the boundaries:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parser: only does the parsing of the source code and converts it into a form suitable for execution via the Virtual Machine (&amp;ldquo;bytecode&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Virtual Machine: the primary &amp;ldquo;computational device,&amp;rdquo; it operates on the bytecode and actually &amp;ldquo;runs&amp;rdquo; the program&lt;/li&gt;
&lt;li&gt;Runtime: machinery required by the parser and VM (e.g., VM state manipulation, resource management, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A naÃ¯ve approach to building the compiler is to tear the interpreter apart: replace VM and runtime with codegen and embed the runtime into the resulting executable. However, the runtime extraction won&amp;rsquo;t work due to the dynamism mentioned above - the resulting executable should be able to parse and run any arbitrary Ruby code.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Side note: an alternative approach is to build a JIT compiler and embed the whole compiler into the executable, but it adds more complexity than I am ready to deal with.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In the end, the solution is simpler - the compiler and the final executable include the whole interpreter. So the final &amp;ldquo;compiling interpreter&amp;rdquo; (or &amp;ldquo;interpreting compiler&amp;rdquo;) looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-1/compiler.png&#34; alt=&#34;Compiling interpreter&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ruby-and-its-many-virtual-machines&#34;&gt;Ruby and its many Virtual Machines&lt;/h3&gt;
&lt;p&gt;Now it&amp;rsquo;s time to discuss the &lt;code&gt;Virtual Machine&lt;/code&gt; component.&lt;/p&gt;
&lt;p&gt;The most widely used Ruby implementation is CRuby, also known as MRI (as in &amp;ldquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/Yukihiro_Matsumoto&#34;&gt;Matz&lt;/a&gt;&amp;rsquo; Ruby Interpreter&amp;rdquo;). It is an interpreter built on top of a custom virtual machine (YARV).&lt;/p&gt;
&lt;p&gt;Another widely used implementation is &lt;a href=&#34;https://mruby.org&#34;&gt;mruby&lt;/a&gt; (so-called &amp;ldquo;embedded&amp;rdquo; Ruby). It is also an interpreter and built on top of another custom VM (RiteVM).&lt;/p&gt;
&lt;p&gt;YARV and RiteVM are rather lightweight virtual machines. Unlike full-fledged system or process-level VMs (e.g., VirtualBox, JVM, CLR, etc.), they only provide a &amp;ldquo;computational device&amp;rdquo; - there is no resource control, sandboxing, etc.&lt;/p&gt;
&lt;h4 id=&#34;stack-vs-registers&#34;&gt;Stack vs. Registers&lt;/h4&gt;
&lt;p&gt;The &amp;ldquo;computational device&amp;rdquo; executes certain operations on certain data.
The operations are encoded in the form of a &amp;ldquo;bytecode.&amp;rdquo; And the data is stored on a &amp;ldquo;virtual stack&amp;rdquo;. Though, the stack is accessed differently.&lt;/p&gt;
&lt;p&gt;YARV accesses the stack implicitly (this is also known as a &amp;ldquo;stack-based VM&amp;rdquo;). RiteVM accesses the stack explicitly via registers (you got it, &amp;ldquo;register-based VM&amp;rdquo;).&lt;/p&gt;
&lt;p&gt;To illustrate the bytecode and the difference between YARV and RiteVM, consider the following artificial examples.&lt;/p&gt;
&lt;p&gt;Stack-based bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;plus&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Register-based bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;plus&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The stack-based version uses the stack implicitly, while another version specifies the storage explicitly.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s &amp;ldquo;run&amp;rdquo; both examples to see them in action.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-1/vm-execution.png&#34; alt=&#34;Comparison of stack and register-based VMs&#34;&gt;&lt;/p&gt;
&lt;p&gt;At every step, the VM does something according to the currently running instruction/opcode (underscored lines) and updates the virtual stack.&lt;/p&gt;
&lt;p&gt;Stack-based VM only reads/writes data from/to the place where an arrow points to - this is the top of the virtual stack.&lt;/p&gt;
&lt;p&gt;Register-based VM does the same but has random access to the virtual stack.&lt;/p&gt;
&lt;p&gt;While the underlying machinery is very similar, there are good reasons for picking one or the other form of a VM. Yet, these reasons are out of the scope of this series. Please, consult elsewhere if you want to learn more.
The topic of VMs is huge but fascinating.&lt;/p&gt;
&lt;h4 id=&#34;dispatch-loop&#34;&gt;Dispatch loop&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s consider how the VM works and deals with the bytecode.
YARV and RiteVM use the so-called &amp;ldquo;dispatch loop,&amp;rdquo; which is effectively a for-loop + a huge &lt;code&gt;switch&lt;/code&gt;-statement. Typical pseudocode looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Iterate through each opcode in the bytecode stream
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (opcode in bytecode) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; (opcode) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Take a corresponding action for each separate opcode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_CODE_1: &lt;span style=&#34;color:#75715e&#34;&gt;/* do something */&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_CODE_2: &lt;span style=&#34;color:#75715e&#34;&gt;/* do something */&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// ... more opcodes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_CODE_N: &lt;span style=&#34;color:#75715e&#34;&gt;/* do something */&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And then, the bodies for the actual opcodes may look as follows.
Stack-based VM:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;Example program:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load 32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; plus
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; print
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_LOAD:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pool[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#75715e&#34;&gt;// pool is some abstract additional storage
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  stack.&lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;(val)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_PLUS:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lhs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stack.&lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rhs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stack.&lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lhs &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; rhs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stack.&lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;(res)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_PRINT:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stack.&lt;span style=&#34;color:#a6e22e&#34;&gt;pop&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(val)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And the register-based version for completeness:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;Example program:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load R1 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load R2 32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; plus R1 R1 R2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; print R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// md is some additional opcode metadata
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_LOAD:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  registers[md.reg1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pool[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_PLUS:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lhs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; registers[md.reg1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rhs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; registers[md.reg2]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lhs &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; rhs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  registers[md.reg1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_PRINT:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; registers[md.reg1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(val)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case, if we know the values behind &lt;code&gt;pool[0]&lt;/code&gt; and the actual values of &lt;code&gt;md.regN&lt;/code&gt;, then we compile the example program to something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load R1 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load R2 32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; plus R1 R1 R2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; print R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;R1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;R2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;R1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; R1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; R2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;(R1)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;and avoid the whole dispatch loop, but I digress :)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;In the following article, we look into mruby&amp;rsquo;s implementation and virtual machine in more detail - &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-2/&#34;&gt;Compiling Ruby. Part 2: RiteVM&lt;/a&gt;.&lt;/p&gt;
</description>
      </item>
      

    

      
        <item>
        <title>Compiling Ruby. Part 0: Motivation</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-0/</link>
        <pubDate>Fri, 02 Dec 2022</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-0/</guid>
        <description>&lt;p&gt;For the last couple of years, I&amp;rsquo;ve been working on a fun side project called &lt;a href=&#34;https://dragonruby.org/toolkit/game&#34;&gt;DragonRuby Game Toolkit&lt;/a&gt;, or GTK for short.&lt;/p&gt;
&lt;p&gt;GTK is a professional-grade 2D game engine. Among the many incredible features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you can build games in Ruby&lt;/li&gt;
&lt;li&gt;it targets many (like, many!) platforms (Windows, Linux, macOS, iOS, Android, WASM, Nintendo Switch, Xbox, PlayStation, Oculus VR, Steam Deck)&lt;/li&gt;
&lt;li&gt;super lightweight (~3.5 megabytes)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dragonruby.org/toolkit/game&#34;&gt;and many more really&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GTK is built on top of a slightly customized mruby runtime and allows you to write games purely in Ruby. It comes with all the batteries included, but if you need more in a specific case, you can always fall back to C via the C extensions mechanism.&lt;/p&gt;
&lt;p&gt;From a user perspective, the end product (the game) looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-0/end-product.png&#34; alt=&#34;End Product&#34;&gt;&lt;/p&gt;
&lt;p&gt;While the engine itself is pretty fast, what annoys me personally (from the aesthetic point of view) is that we cannot fully optimize the C extensions as they are compiled separately from the rest of the engine.&lt;/p&gt;
&lt;p&gt;Looking at the picture, we have four components of the game:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the engine&amp;rsquo;s runtime (Ruby)&lt;/li&gt;
&lt;li&gt;the engine&amp;rsquo;s runtime (C)&lt;/li&gt;
&lt;li&gt;the game code (Ruby)&lt;/li&gt;
&lt;li&gt;the game code (C)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Suppose we want to optimize all the C code together. In that case, we&amp;rsquo;d have to ship the runtime in some &amp;lsquo;common&amp;rsquo; denominator form (e.g., &lt;a href=&#34;https://lowlevelbits.org/bitcode-demystified/&#34;&gt;LLVM Bitcode&lt;/a&gt;), then compile the C extension into the same form, optimize it all together and then link into an executable.&lt;/p&gt;
&lt;p&gt;This is doable, but while I was thinking about this problem I&amp;rsquo;ve found even bigger (and much more interesting) &amp;lsquo;problem&amp;rsquo; - what about all that Ruby code? Can we also compile it to some common form and then optimize it with the rest of the C code out there?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-0/optimizations.png&#34; alt=&#34;Optimizations&#34;&gt;&lt;/p&gt;
&lt;p&gt;The answer is - definitely yes! We just need to build a compiler that would do that job.&lt;/p&gt;
&lt;p&gt;At the time of writing, the compiler is far from being done, but it works reasonably well, and I can successfully compile and run more than half of the mruby test suite.&lt;/p&gt;
&lt;p&gt;As a sneak peek, here is an output from the test suite:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/opt/DragonRuby/FireStorm/cmake-build-llvm-14-asan/tests/MrbTests/firestorm_mrbtest
mrbtest - Embeddable Ruby Test

............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................?.........................................................................................................................
Skip: File.expand_path (with ENV)
 Total: 934
 OK: 933
 KO: 0
 Crash: 0
 Warning: 0
 Skip: 1
 Time: 0.45 seconds

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;I hope this motivation gives you enough information on why someone would do what I am doing!&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a look at the approach I am taking to solve this problem - &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-1/&#34;&gt;Compilers vs. Interpreters&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
      

    
  </channel>
</rss>
