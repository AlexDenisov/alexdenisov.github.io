<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cfg on Low Level Bits ðŸ‡ºðŸ‡¦</title>
    <link>https://lowlevelbits.org/tags/cfg/</link>
    <description>Recent content in cfg on Low Level Bits ðŸ‡ºðŸ‡¦</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>alex@lowlevelbits.org (Alex Denisov)</managingEditor>
    <webMaster>alex@lowlevelbits.org (Alex Denisov)</webMaster>
    <lastBuildDate>Fri, 06 Jan 2023 02:00:00 +0100</lastBuildDate>
    <atom:link href="" rel="self" type="application/rss+xml" />
    

      
        <item>
        <title>Compiling Ruby. Part 3: MLIR and compilation</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-3/</link>
        <pubDate>Fri, 06 Jan 2023</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-3/</guid>
        <description>&lt;p&gt;Now as we have a decent understanding of how RiteVM works, we can tackle the compilation.
The question I had around two years ago - how do I even do this?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A note of warning: so far, this is the longest article on this blog. And I&amp;rsquo;m afraid the most cryptic one.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The topics covered here:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MLIR&lt;/li&gt;
&lt;li&gt;Control-Flow Graphs (CFG)&lt;/li&gt;
&lt;li&gt;Static Single Assignment (SSA)&lt;/li&gt;
&lt;li&gt;Dataflow Analysis&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;compilation&#34;&gt;Compilation&lt;/h3&gt;
&lt;p&gt;mruby is written in C, so the logic behind each opcode is implemented in C. To compile a Ruby program from bytecode, we can emit an equivalent C program that uses mruby C API.&lt;/p&gt;
&lt;p&gt;Some opcodes have direct API counterparts, e.g., &lt;code&gt;OP_LOADI&lt;/code&gt; is equivalent to &lt;code&gt;mrb_value mrb_fixnum_value(mrb_int i);&lt;/code&gt;. Yet, most opcodes are inlined in the giant dispatch loop in &lt;code&gt;vm.c&lt;/code&gt;. However, we can extract these implementations into separate functions and call them from C.&lt;/p&gt;
&lt;p&gt;Consider the following Ruby program:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;puts &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;and its bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADSELF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_SEND&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;  :&lt;span style=&#34;color:#66d9ef&#34;&gt;puts&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_RETURN&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_STOP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;An equivalent C program looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mrb_state &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;mrb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mrb_open();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mrb_value receiver &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fs_load_self();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mrb_value number &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mrb_fixnum_value(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mrb_funcall(mrb, receiver, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;puts&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;number);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mrb_close(mrb);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;code&gt;fs_load_self&lt;/code&gt; is a custom runtime function as &lt;code&gt;OP_LOADSELF&lt;/code&gt; doesn&amp;rsquo;t have a C API counterpart.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;code&gt;OP_RETURN&lt;/code&gt; is ignored in this small example.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;To compile a Ruby program from its bytecode, we &amp;ldquo;just&amp;rdquo; need to generate the equivalent C program. In fact, this is what I did to start two years ago.
It worked well and had some nice debugging capabilities - in the end, it&amp;rsquo;s just a C program.&lt;/p&gt;
&lt;p&gt;Yet, at some point, the implementation became daunting. As I was generating a C program, it was pretty hard to do some custom analysis or optimizations on the C code. I started adding my auxiliary data structures (really, just arrays of hashmaps of hashmaps of pairs and tuples) before I generated the C code.&lt;/p&gt;
&lt;p&gt;I realized I was about to invent my intermediate representation of questionable quality.&lt;/p&gt;
&lt;p&gt;I needed a better solution.&lt;/p&gt;
&lt;h3 id=&#34;mlir&#34;&gt;MLIR&lt;/h3&gt;
&lt;p&gt;I remember watching the &lt;a href=&#34;https://www.youtube.com/watch?v=qzljG6DKgic&#34;&gt;MLIR talk&lt;/a&gt; by Tatiana Shpeisman and Chris Lattner live at EuroLLVM in Brussels. It went over my head back then, as there was a lot of talk about machine learning, tensors, heterogeneous accelerators, and some other dark magic.&lt;/p&gt;
&lt;p&gt;Yet, I also remember some mentions of custom intermediate representations. So I decided to give it a try and dig into it more. It turned out to be great.&lt;/p&gt;
&lt;p&gt;One of the key features of MLIR is the ability to define custom intermediate representations called &lt;em&gt;dialects&lt;/em&gt;. MLIR provides an infrastructure to mix and match different dialects and run analyses or transformations against them. Further, the dialects can be lowered to machine code (e.g., for CPU or GPU).&lt;/p&gt;
&lt;p&gt;Here is a slide from my &lt;a href=&#34;https://www.youtube.com/watch?v=Cl5SgDxvZ8w&#34;&gt;LLVM Social talk&lt;/a&gt; to illustrate the idea:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-3/what-is-mlir.png&#34; alt=&#34;What is MLIR?&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mlir-rite-dialect&#34;&gt;MLIR Rite Dialect&lt;/h3&gt;
&lt;p&gt;I need to define a custom dialect to make MLIR work for my use case. I called it &amp;ldquo;Rite.&amp;rdquo; The dialect needs an operation of each RiteVM opcode and some RiteVM types.&lt;/p&gt;
&lt;p&gt;Here is the minimum required to compile the code sample from above (&lt;code&gt;puts 42&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Rite_Dialect&lt;/span&gt; : Dialect {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rite&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;A one-to-one mapping from mruby RITE VM bytecode to MLIR&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let cppNamespace &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rite&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RiteType&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;string name&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; : TypeDef&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Rite_Dialect, name&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let mnemonic &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ValueType&lt;/span&gt; : RiteType&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;StateType&lt;/span&gt; : RiteType&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;state&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Rite_Op&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;string mnemonic, list&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Trait&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; traits &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; :
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Rite_Dialect, mnemonic, traits&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; OPCODE(LOADSELF, B) &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; R(a) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadSelfOp&lt;/span&gt; : Rite_Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_LOADSELF&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_LOADSELF&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (outs ValueType);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; OPCODE(LOADI, BB) &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; R(a) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mrb_int(b) &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LoadIOp&lt;/span&gt; : Rite_Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_LOADI&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_LOADI&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let arguments &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ins SI64Attr:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;value);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (outs ValueType);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; OPCODE(SEND, BBB) &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; R(a) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; call(R(a),Syms(b),R(a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;),&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;,R(a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;c)) &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SendOp&lt;/span&gt; : Rite_Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_SEND&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_SEND&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let arguments &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ins ValueType:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;receiver, StringAttr:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;symbol, UI32Attr:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;argc, Variadic&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;ValueType&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;argv);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (outs ValueType);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt; OPCODE(RETURN, B) &lt;span style=&#34;color:#f92672&#34;&gt;/*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; R(a) (normal) &lt;span style=&#34;color:#f92672&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReturnOp&lt;/span&gt; : Rite_Op&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_RETURN&amp;#34;&lt;/span&gt;, [Terminator]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let summary &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;OP_RETURN&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let arguments &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ins ValueType:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;src);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  let results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (outs ValueType);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It defines the dialect, the types needed, and the operations.
Some entities come from the MLIR&amp;rsquo;s predefined dialects (&lt;code&gt;StringAttr&lt;/code&gt;, &lt;code&gt;UI32Attr&lt;/code&gt;, &lt;code&gt;Variadic&amp;lt;...&amp;gt;&lt;/code&gt;, &lt;code&gt;Terminator&lt;/code&gt;). We define the rest.&lt;/p&gt;
&lt;p&gt;Each operation may take zero or more arguments, but it also may produce zero or more results. Unlike a &amp;ldquo;typical&amp;rdquo; programming language, MLIR dialects define a graph (as &lt;code&gt;ins&lt;/code&gt; and &lt;code&gt;outs&lt;/code&gt; hint at). The dialects also have some other properties, but one step at a time.&lt;/p&gt;
&lt;p&gt;With the dialect in place, I can generate an &amp;ldquo;MLIR program&amp;rdquo; which is roughly equivalent to the C program above:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: I omit some details for brevity.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;module &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;@&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;test.rb&amp;#34;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    %0 = rite.OP_LOADSELF() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    %1 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    %2 = rite.OP_SEND(%0, %1) {argc = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; : ui32, symbol = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;puts&amp;#34;&lt;/span&gt;} : (!rite.value, !rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    %3 = rite.OP_RETURN(%2) : (!rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here, I generated an MLIR module containing a function (&lt;code&gt;top&lt;/code&gt;) with four operations corresponding to each bytecode operation.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a detailed look at one operation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;%2 = rite.OP_SEND(%0, %1) {argc = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; : ui32, symbol = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;puts&amp;#34;&lt;/span&gt;} : (!rite.value, !rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This piece defines a value named &lt;code&gt;%2&lt;/code&gt;, which takes two other values (&lt;code&gt;%0&lt;/code&gt; and &lt;code&gt;%1&lt;/code&gt;). In MLIR, constants are defined as &amp;ldquo;attributes,&amp;rdquo; which are &lt;code&gt;argc = 1 : ui32&lt;/code&gt; and &lt;code&gt;symbol = &amp;quot;puts&amp;quot;&lt;/code&gt; in this case. What follows is the operation signature &lt;code&gt;(!rite.value, !rite.value) -&amp;gt; !rite.value&lt;/code&gt;. The operation returns &lt;code&gt;rite.value&lt;/code&gt; and takes several arguments: &lt;code&gt;%0&lt;/code&gt; is the receiver, and &lt;code&gt;%1&lt;/code&gt; is part of the &lt;code&gt;Variadic&amp;lt;ValueType&amp;gt;:$argv&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;MLIR takes the declarative dialect definition and generates C++ code out of it. The C++ code serves as a programmatic API to generate the MLIR module.&lt;/p&gt;
&lt;p&gt;Once the module is generated, I can analyze and transform it. The next step is directly converting the Rite Dialect into LLVM Dialect and lowering it into LLVM IR.&lt;/p&gt;
&lt;p&gt;From there on, I can emit an object file (machine code) and link it with mruby runtime.&lt;/p&gt;
&lt;h3 id=&#34;static-single-assignment-ssa&#34;&gt;Static Single Assignment (SSA)&lt;/h3&gt;
&lt;p&gt;In the previous article, I mentioned that the virtual stack is essential, yet here in both C and MLIR programs, I use &amp;ldquo;local variables&amp;rdquo; instead of the stack. What&amp;rsquo;s going on here?&lt;/p&gt;
&lt;p&gt;The answer is simple - MLIR uses a Static Single-Assignment form for all its representations.&lt;/p&gt;
&lt;p&gt;As a reminder, SSA means that each variable can only be defined once.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Pedantic note: the &amp;ldquo;variables&amp;rdquo; should be referred to as &amp;ldquo;values&amp;rdquo; as they cannot vary.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Here is an &amp;ldquo;invalid&amp;rdquo; SSA form:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// redefinition not allowed in SSA
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;print(x);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And here is the same code in the SSA form:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;55&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// &amp;#34;redefinition&amp;#34; generates a new value
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;print(x1);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We must convert the registers into SSA values to satisfy the MLIR requirement to be in SSA form.&lt;/p&gt;
&lt;p&gt;At first glance, the problem is trivial. We can maintain a map of definitions for each register at each point in time. For example, for the following bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADSELF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// #1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// #2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// #3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// #4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_ADD&lt;/span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// #5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;OP_RETURN&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// #6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The map changes as follows:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Step #1: { empty }
Step #2: {
  R1 defined by #1
}
Step #3: {
  R1 defined by #1
  R2 defined by #2
}
Step #4: {
  R1 defined by #1
  R2 defined by #2
  R3 defined by #3
}
Step #5: {
  R1 defined by #1
  R2 defined by #2
  R3 defined by #4 // R3 redefined at #4
}
Step #5: {
  R1 defined by #1
  R2 defined by #5 // OP_ADD stores the result in the first operand
  R3 defined by #4
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this map, we know precisely where a register was defined when an operation uses the register.&lt;/p&gt;
&lt;p&gt;So MLIR version will look like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_LOADSELF R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%0 = rite.OP_LOADSELF() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_LOADI    R2 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%1 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_LOADI    R3 20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%2 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_LOADI    R3 30
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%3 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_ADD      R2 R3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%4 = rite.OP_ADD(%1, %3) : (!rite.value, !rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// OP_RETURN   R2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;%5 = rite.OP_RETURN(%4) : (!rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;Side note: &lt;code&gt;%0&lt;/code&gt; and &lt;code&gt;%2&lt;/code&gt; are never used and can be eliminated (if &lt;code&gt;OP_LOADSELF&lt;/code&gt;/&lt;code&gt;OP_LOADI&lt;/code&gt; don&amp;rsquo;t have side effects).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This solution is pleasant until the code has branching such as &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, loops, or exceptions.&lt;/p&gt;
&lt;p&gt;Consider the following non-SSA example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (something) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(x); &lt;span style=&#34;color:#75715e&#34;&gt;// Where x is defined?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Classical SSA solves this problem with artificial &lt;code&gt;phi&lt;/code&gt;-nodes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (something) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; phi(x2, x3); &lt;span style=&#34;color:#75715e&#34;&gt;// Will magically resolve to the right x depending on where it comes from
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;print(x4);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;MLIR approaches this differently and elegantly - via &amp;ldquo;block arguments.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;But first, let&amp;rsquo;s talk about Control-Flow Graphs.&lt;/p&gt;
&lt;h3 id=&#34;control-flow-graph-cfg&#34;&gt;Control-Flow Graph (CFG)&lt;/h3&gt;
&lt;p&gt;A control-flow graph is a form of intermediate representation that maintains the program in the form of a graph where operations are connected to each other based on the execution (or control) flow.&lt;/p&gt;
&lt;p&gt;Consider the following bytecode (the number on the left is an operation address):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;001:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// puts &amp;#34;true&amp;#34; in R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;002:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;003:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMPIF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// jump to 006 if R1 contains &amp;#34;true&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                      &lt;span style=&#34;color:#75715e&#34;&gt;// otherwise implicitly falls through to 004
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;004:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;005:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMP&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;// jump to 007 unconditionally
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;006:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;007:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_ADD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// R3 may be either 20 or 30, depending on the branching
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The same program in the form of a graph:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-3/naive-cfg.png&#34; alt=&#34;CFG without basic blocks&#34;&gt;&lt;/p&gt;
&lt;p&gt;This CFG can be further optimized: we can merge all the subsequent nodes unless the node has more than one incoming or more than one outgoing edge.&lt;/p&gt;
&lt;p&gt;The merged nodes are called basic blocks:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-3/complete-cfg.png&#34; alt=&#34;CFG with basic blocks&#34;&gt;&lt;/p&gt;
&lt;p&gt;Some more terms for completeness:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &amp;ldquo;first&amp;rdquo; basic block where the execution of a function starts is called &amp;ldquo;entry.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;similarly, the &amp;ldquo;last&amp;rdquo; basic block is called &amp;ldquo;exit.&amp;rdquo;&lt;/li&gt;
&lt;li&gt;preceding (incoming, previous) basic blocks are called predecessors. The entry block doesn&amp;rsquo;t have predecessors.&lt;/li&gt;
&lt;li&gt;succeeding (outgoing, next) basic blocks are called successors. Exit blocks don&amp;rsquo;t have successors.&lt;/li&gt;
&lt;li&gt;the last operation in a basic block is called a terminator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Based on the last picture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;B1&lt;/code&gt;: entry block&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B4&lt;/code&gt;: single exit block. There could be several exit blocks, yet we can always add one &amp;ldquo;empty&amp;rdquo; block as a successor for the exit blocks to have only one exit block.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B1&lt;/code&gt;: predecessors: [], successors: [&lt;code&gt;B2&lt;/code&gt;, &lt;code&gt;B3&lt;/code&gt;], terminator: &lt;code&gt;OP_JMPIF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B2&lt;/code&gt;: predecessors: [&lt;code&gt;B1&lt;/code&gt;], successors: [&lt;code&gt;B4&lt;/code&gt;], terminator: &lt;code&gt;OP_JMP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B3&lt;/code&gt;: predecessors: [&lt;code&gt;B1&lt;/code&gt;], successors: [&lt;code&gt;B4&lt;/code&gt;], terminator: &lt;code&gt;OP_LOADI&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B4&lt;/code&gt;: predecessors: [&lt;code&gt;B2&lt;/code&gt;, &lt;code&gt;B3&lt;/code&gt;], successors: [], terminator: &lt;code&gt;OP_ADD&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cfgs-in-mlir&#34;&gt;CFGs in MLIR&lt;/h3&gt;
&lt;p&gt;Now we can take a look at CFGs from the MLIR perspective. If you are familiar with CFGs in LLVM, then the important difference is that in MLIR, all the basic blocks may have arguments. Function arguments are, in fact, the block arguments from the entry block. For example, this is a more accurate representation of a function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;() -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb0(%arg0: !rite.state, %arg1: !rite.value):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %0 = rite.OP_LOADSELF() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %1 = rite.OP_LOADI() {value = &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; : si64} : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %2 = rite.OP_SEND(%0, %1) {argc = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; : ui32, symbol = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;puts&amp;#34;&lt;/span&gt;} : (!rite.value, !rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %3 = rite.OP_RETURN(%2) : (!rite.value) -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;Note, &lt;code&gt;^bbX&lt;/code&gt; represents the basic blocks.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;To convert the following bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;001:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;// puts &amp;#34;true&amp;#34; in R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;002:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;003:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMPIF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// jump to 006 if R1 contains &amp;#34;true&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                      &lt;span style=&#34;color:#75715e&#34;&gt;// otherwise implicitly falls through to 004
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;004:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;005:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMP&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;// jump to 007 unconditionally
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;006:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;007:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_ADD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;// R3 may be either 20 or 30, depending on the branching
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;we need to take several steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;add an address attribute to all addressable operations (they could be jump targets)&lt;/li&gt;
&lt;li&gt;add &amp;ldquo;targets&amp;rdquo; attribute to all the jumps, including implicit fallthrough jumps&lt;/li&gt;
&lt;li&gt;add an explicit jump in place of the implicit jumps&lt;/li&gt;
&lt;li&gt;add the successor blocks for all jump instructions&lt;/li&gt;
&lt;li&gt;put all the operations in a single, entry basic block&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %1 = rite.OP_LOADT() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;001&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %2 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;002&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.OP_JMPIF(%0)[^bb1, ^bb1] { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;003&lt;/span&gt;, targets = [&lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;004&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %3 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;004&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.OP_JMP()[^bb1] { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;005&lt;/span&gt;, targets = [&lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %4 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.FallthroughJump()[^bb1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %5 = rite.OP_ADD(%0, %0) { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;Note: I&amp;rsquo;m omitting some details from the textual representation for brevity.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Notice, here, I added a &amp;ldquo;phony value&amp;rdquo; as a placeholder for SSA values as we cannot yet construct the proper SSA. We will remove them in the next section.&lt;/p&gt;
&lt;p&gt;Additionally, I added a phony basic block to serve as a placeholder successor for the jump targets.&lt;/p&gt;
&lt;p&gt;Now, the last steps are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;split the entry basic block by cutting it right before each jump target operation&lt;/li&gt;
&lt;li&gt;rewire the jumps to point to the right target basic blocks&lt;/li&gt;
&lt;li&gt;delete the phony basic block used as a placeholder&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The final CFG looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %1 = rite.OP_LOADT() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;001&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %2 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;002&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.OP_JMPIF(%0)[^bb1, ^bb2] { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;003&lt;/span&gt;, targets = [&lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;004&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;004&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.OP_JMP()[^bb3] { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;005&lt;/span&gt;, targets = [&lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI() { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;, value = &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rite.FallthroughJump()[^bb3]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%0, %0) { address = &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt; } : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It corresponds to the last picture above, except that we now have an explicit &lt;code&gt;rite.FallthroughJump()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With the CFG in place, we can solve the SSA problem and eliminate the &lt;code&gt;rite.PhonyValue()&lt;/code&gt; placeholder.&lt;/p&gt;
&lt;h3 id=&#34;ssa-in-mlir&#34;&gt;SSA in MLIR&lt;/h3&gt;
&lt;p&gt;As a reminder, here is the CFG of the &amp;ldquo;problematic&amp;rdquo; program:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-3/complete-cfg.png&#34; alt=&#34;CFG with basic blocks&#34;&gt;&lt;/p&gt;
&lt;p&gt;In the MLIR form, we no longer have registers from the virtual stack. We only have values such as &lt;code&gt;%2&lt;/code&gt;, &lt;code&gt;%3&lt;/code&gt;, &lt;code&gt;%4&lt;/code&gt;, and so on. The tricky part is the &lt;code&gt;007: OP_ADD R2 R3&lt;/code&gt; operation - where &lt;code&gt;R3&lt;/code&gt; is coming from? Is it &lt;code&gt;%3&lt;/code&gt; or &lt;code&gt;%4&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;To answer this question, we can use &lt;a href=&#34;https://en.wikipedia.org/wiki/Data-flow_analysis&#34;&gt;Data-flow analysis&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Dataflow analysis is used to derive specific facts about the program. The analysis is an iterative process: first, collect the base facts for each basic block, then for each basic block, update the facts combining them with the facts from successors or predecessors. As the facts updated for a basic block may affect the facts from successors/predecessors, the process should run iteratively until no new facts are derived.&lt;/p&gt;
&lt;p&gt;A critical requirement for the facts - they should be monotonic. Once the fact is known, it cannot &amp;ldquo;disappear.&amp;rdquo; This way, the iterative process eventually stops as, in the worst case, the analysis will derive &amp;ldquo;all&amp;rdquo; the facts about the program and won&amp;rsquo;t be able to derive any more.&lt;/p&gt;
&lt;p&gt;My favorite resource about dataflow analysis is Adrian Sampson&amp;rsquo;s lectures on the subject - &lt;a href=&#34;https://www.cs.cornell.edu/courses/cs6120/2020fa/lesson/4/&#34;&gt;The Data Flow Framework&lt;/a&gt;. I highly recommend it.&lt;/p&gt;
&lt;p&gt;In our case, the facts we need to derive are: which values/registers are required for each operation.&lt;/p&gt;
&lt;p&gt;Here is an algorithm briefly:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;at every point in time, there is a map of the values defined so far&lt;/li&gt;
&lt;li&gt;if an operation is using a value that is not defined, then this value is &lt;code&gt;required&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;the required values become the block arguments and must be coming from the predecessors&lt;/li&gt;
&lt;li&gt;the terminators of the &amp;ldquo;required&amp;rdquo; predecessors now use the values required by the successors&lt;/li&gt;
&lt;li&gt;at the next iteration, the block arguments define the previously required values&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The process runs iteratively until no new required values appear.&lt;/p&gt;
&lt;p&gt;An important detail for the entry basic block is that, as it doesn&amp;rsquo;t have a predecessor, all the required values must come from the virtual stack.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look a the example bytecode once again:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;001:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADT&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;002:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;003:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMPIF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;006&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;004:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;005:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_JMP&lt;/span&gt;   &lt;span style=&#34;color:#ae81ff&#34;&gt;007&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;006:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;007:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;OP_ADD&lt;/span&gt;   &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is the initial state for the dataflow analysis. The comments above contain information about defined values for the given point in time. Comment on the side of each operation tells about the operation itself:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %1 = rite.OP_LOADT() : () -&amp;gt; !rite.value     &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R1], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %2 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1, R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMPIF(%0)[^bb1, ^bb2]                &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                            // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMP()[^bb3]                          &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                            // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.FallthroughJump()[^bb3]                 &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2                      // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%0, %0) : () -&amp;gt; !rite.value &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The last operation uses values that are not defined. Therefore &lt;code&gt;R2&lt;/code&gt; and &lt;code&gt;R3&lt;/code&gt; are required and must come from the predecessors.&lt;/p&gt;
&lt;p&gt;Update predecessors and rerun the analysis.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note: I am using %RX_Y names to distinguish them from the original numerical value names. X is the register number, and Y is the basic block number.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %1 = rite.OP_LOADT() : () -&amp;gt; !rite.value     &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R1], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %2 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1, R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMPIF(%0)[^bb1, ^bb2]                &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                            // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMP(%0, %0)[^bb3]                    &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2: &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                            // defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.FallthroughJump(%0, %0)[^bb3]           &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3(%R2_3, %R3_3): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2        // defines: [R2, R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%0, %0) : () -&amp;gt; !rite.value &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Basic block &lt;code&gt;^bb3&lt;/code&gt; now has two block arguments.
The terminators from its predecessors (&lt;code&gt;^bb1&lt;/code&gt; and &lt;code&gt;^bb2&lt;/code&gt;) now use an undefined value, &lt;code&gt;R2&lt;/code&gt;. &lt;code&gt;R2&lt;/code&gt; is now required. We must add it as a block argument and propagate it to the predecessors&amp;rsquo; terminators.&lt;/p&gt;
&lt;p&gt;Rerun the analysis:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %0 = rite.PhonyValue() : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %1 = rite.OP_LOADT() : () -&amp;gt; !rite.value     &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R1], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %2 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R1, R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMPIF(%0, %0, %0)[^bb1, ^bb2]        &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R1, R2, R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1(%R2_1): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                     // defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.OP_JMP(%0, %0)[^bb3]                    &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2(%R2_2): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0                     // defines: [R2], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) : () -&amp;gt; !rite.value   &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  rite.FallthroughJump(%0, %0)[^bb3]           &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3(%R2_3, %R3_3): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2        // defines: [R2, R3], uses: []
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// defined: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%0, %0) : () -&amp;gt; !rite.value &lt;span style=&#34;color:#75715e&#34;&gt;// defines: [R2], uses: [R2, R3]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can run the analysis one more time, but it won&amp;rsquo;t change anything, so that would conclude the analysis, and we should have all the information we need to replace the phony value with the correct values.&lt;/p&gt;
&lt;p&gt;Additionally, now we can replace our custom jump operations with the builtin ones from MLIR, so the final function looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-mlir&#34; data-lang=&#34;mlir&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@top&lt;/span&gt;(%arg0: !rite.state, %arg1: !rite.value) -&amp;gt; !rite.value {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %1 = rite.OP_LOADT() : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  %2 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt;) : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  cond_br %1, ^bb1(%2), ^bb2(%2)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb1(%R2_1): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %3 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;) : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  br ^bb3(%R2_1, %3)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb2(%R2_2): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %4 = rite.OP_LOADI(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;) : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  br ^bb3(%R2_2, %4)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;^bb3(%R2_3, %R3_3): &lt;span style=&#34;color:#75715e&#34;&gt;// pred: ^bb1, ^bb2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  %5 = rite.OP_ADD(%R2_3, %R3_3) : () -&amp;gt; !rite.value
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now, onto drawing the rest of the fu**ing owl.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Thank you so much for reaching this far!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The following articles will focus on documenting mruby&amp;rsquo;s implementation details.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://lowlevelbits.org/subscribe/&#34;&gt;Don&amp;rsquo;t miss those details!&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
      

    

      
        <item>
        <title>How to learn compilers: LLVM Edition</title>
        <link>https://lowlevelbits.org/how-to-learn-compilers-llvm-edition/</link>
        <pubDate>Thu, 04 Nov 2021</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/how-to-learn-compilers-llvm-edition/</guid>
        <description>&lt;p&gt;Compilers and Programming Languages is a huge topic. You cannot just take
a learning path and finish it at some point. There are many different areas,
each of which is endless.&lt;/p&gt;
&lt;p&gt;Here, I want to share some links that would help to learn compilers.
The list could not be exhaustive - everyone is busy, and no one has time to read the &lt;a href=&#34;https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools&#34;&gt;Dragon Book&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The main criteria behind each link:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I can personally recommend the material as I went through it&lt;/li&gt;
&lt;li&gt;each entry should be relatively short and can be consumed in a reasonable time&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&amp;rsquo;m a big fan of learning through practicing. Thus the main focus is on LLVM, as you can go and do something cool with real-world programs!&lt;/p&gt;
&lt;p&gt;The list consists of four groups: general theory, front-end, middle-end, and back-end.&lt;/p&gt;
&lt;p&gt;At the first run, you can take the first item from each group, and it should put you on solid ground.&lt;/p&gt;
&lt;h3 id=&#34;disclaimer&#34;&gt;Disclaimer&lt;/h3&gt;
&lt;p&gt;There are a lot of excellent resources out there!
Some of them are not on the list because of my subjective judgment, and the others are not here because I&amp;rsquo;ve never seen them!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Please, share your favorite resource either via
&lt;a href=&#34;mailto:alex@lowlevelbits.org&#34;&gt;email&lt;/a&gt; or on &lt;a href=&#34;https://twitter.com/1101_debian/status/1456346324794806274&#34;&gt;Twitter&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;general-theory--introduction&#34;&gt;General Theory / Introduction&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://aosabook.org/en/llvm.html&#34;&gt;AOSA book: LLVM&lt;/a&gt;.
This is a chapter from the &lt;a href=&#34;http://aosabook.org/en/index.html&#34;&gt;Architecture of Open Source Applications&lt;/a&gt; book.
It is written by Chris Lattner and covers high-level LLVM design.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://online.stanford.edu/courses/soe-ycscs1-compilers&#34;&gt;Compilers&lt;/a&gt;.
The course is taught by Alex Aiken. In this course, you build a compiler for a real programming language from scratch. It covers the whole compilation pipeline: parsing, type-checking, optimizations, code generation. Besides practical parts, it also dives into the theory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://online.stanford.edu/courses/soe-ycsautomata-automata-theory&#34;&gt;Automata Theory&lt;/a&gt;.
The course is taught by Jeffrey Ullman. This one is pretty heavy on theory. It starts with relatively simple topics like state machines and finite automata (deterministic and otherwise). It gradually moves on to more complex things like Turing-machines, computational complexity, famous P vs. NP, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;or&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ocw.mit.edu/courses/mathematics/18-404j-theory-of-computation-fall-2020/&#34;&gt;Theory of Computation&lt;/a&gt;.
This course is taught by Michael Sipser. It is similar to the one above but delivered in a different style. It goes into more detail on specific topics.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;front-end&#34;&gt;Front-end&lt;/h3&gt;
&lt;p&gt;The compiler front-end is where the interaction with the actual source code happens. The compiler parses the source code into an Abstract Syntax Tree (AST), does semantic analysis and type-checking, and converts it into the intermediate representation (IR).&lt;/p&gt;
&lt;p&gt;The Compilers course from the above covers the general parts.
Here are some links specific to Clang:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jonasdevlieghere.com/understanding-the-clang-ast/&#34;&gt;Understanding the Clang AST&lt;/a&gt;.
This article is written by Jonas Devlieghere. It goes into detail and touches implementation details of Clang&amp;rsquo;s AST. It also has a lot of excellent links to dive deeper into the subject.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/banach-space/clang-tutor/&#34;&gt;clang-tutor&lt;/a&gt;. This repository maintained by Andrzej WarzyÅ„ski. It contains several Clang plugins covering various topics, from simple AST traversals to more involved subjects such as automatic refactoring and obfuscation.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;middle-end&#34;&gt;Middle-end&lt;/h3&gt;
&lt;p&gt;The middle-end is a place where various optimizations happen. Typically, the middle-ends use some intermediate representation. The intermediate representation of LLVM is usually referred to as LLVM IR or LLVM Bitcode.
In a nutshell, it is a human-readable assembly language for a pseudo-machine (i.e., the IR does not target any specific CPU).
The LLVM IR maintains certain properties: it is in a Static Single Assignment (SSA) form organized as a Control-Flow Graph (CFG).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=m8G_S5LwlTo&#34;&gt;LLVM IR Tutorial - Phis, GEPs and other things, oh my!&lt;/a&gt;.
This is a great talk by Vince Bridgers and Felipe de Azevedo Piovezan.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=J5xExRGaIIY&#34;&gt;Introduction to LLVM&lt;/a&gt;. A one-hour-long talk/tutorial from LLVM Developers meeting given by Eric Christopher and Johannes Doerfert. Another great tutorial that better builds on top of the previous video.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cs.cornell.edu/courses/cs6120/2020fa/self-guided/&#34;&gt;CS 6120: Advanced Compilers&lt;/a&gt;.
The course is taught by Adrian Sampson. The title says &amp;ldquo;advanced,&amp;rdquo; but it covers what one would expect in a modern production-grade compiler: SSA, CFG, optimizations, various analyses.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://lowlevelbits.org/bitcode-demystified/&#34;&gt;Bitcode Demystified&lt;/a&gt;(ðŸ”Œ).
This one is from me. It gives a high-level description of what&amp;rsquo;s the LLVM
Bitcode is.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/banach-space/llvm-tutor&#34;&gt;llvm-tutor&lt;/a&gt;. This one is also from Andrzej WarzyÅ„ski. It covers LLVM plugins (so-called passes) that allow one to analyze and transform the programs in the LLVM IR form.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;back-end&#34;&gt;Back-end&lt;/h3&gt;
&lt;p&gt;The last phase of the compilation is a back-end. This phase aims to convert the intermediate representation into a machine code (zeros and ones). The zeros and ones later can be run on the CPU. Therefore, to understand the back-end, you need to understand the machine code and how CPUs work.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.coursera.org/learn/build-a-computer&#34;&gt;Build a Modern Computer from First Principles: From Nand to Tetris&lt;/a&gt;.
Taught by Shimon Schocken and Noam Nisan. This course starts backward: first, you build the logic gates (and, or, xor, etc.), then use the logic gates to construct Arithmetic-Logic Unit (ALU), and then use the ALU to build the CPU. Then you learn how to control the CPU with zeros and ones (machine code), and eventually, you develop your assembler to convert the human-readable assembly into the machine code.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://lowlevelbits.org/parsing-mach-o-files/&#34;&gt;Parsing Mach-O files&lt;/a&gt;(ðŸ”Œ).
This is a short article written by me. It shows how to parse object files on macOS (Mach-O). If you are on Linux or Windows, search for similar articles on &lt;code&gt;elf&lt;/code&gt; and &lt;code&gt;PE/COFF&lt;/code&gt; files, respectively.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://book.easyperf.net/perf_book&#34;&gt;Performance Analysis and Tuning on Modern CPUs&lt;/a&gt;.
The book by Denis Bakhvalov. While it is about performance, it gives an excellent introduction to how CPUs work.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bonus-points&#34;&gt;Bonus points&lt;/h3&gt;
&lt;p&gt;Here are some more LLVM related channels I recommend looking at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/channel/UCv2_41bSAa5Y_8BacJUZfjQ&#34;&gt;LLVM&amp;rsquo;s YouTube channel&lt;/a&gt;.
Here you can find a lot of talks from developer meetings.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://llvmweekly.org&#34;&gt;LLVM Weekly&lt;/a&gt;.
A weekly newsletter run by Alex Bradbury. This is the single newsletter
I am aware of that doesn&amp;rsquo;t have ads!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.llvm.org&#34;&gt;LLVM Blog&lt;/a&gt;.
This is, well, LLVM&amp;rsquo;s blog.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://llvm.org/docs/tutorial/&#34;&gt;LLVM Tutorials&lt;/a&gt;.
Good starting points, even if you know nothing about compilers.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.regehr.org/archives/category/compilers&#34;&gt;Embedded in academia&lt;/a&gt;.
John Regehr&amp;rsquo;s blog has lots of goodies when it comes to LLVM and compilers!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;strings-attached&#34;&gt;Strings attached&lt;/h3&gt;
&lt;p&gt;As I mentioned in the beginning, Compilers is a huge field!
If you go through the material above, you will learn a lot, but you will still
have a few knowledge gaps in the whole compilation pipeline (I certainly do).
But the good thing is - you&amp;rsquo;d know what the gaps are and how to address
them!&lt;/p&gt;
&lt;p&gt;Good luck!&lt;/p&gt;
</description>
      </item>
      

    
  </channel>
</rss>
