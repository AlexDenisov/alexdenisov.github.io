<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ruby on Low Level Bits ðŸ‡ºðŸ‡¦</title>
    <link>https://lowlevelbits.org/tags/ruby/</link>
    <description>Recent content in ruby on Low Level Bits ðŸ‡ºðŸ‡¦</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>alex@lowlevelbits.org (Alex Denisov)</managingEditor>
    <webMaster>alex@lowlevelbits.org (Alex Denisov)</webMaster>
    <lastBuildDate>Fri, 02 Dec 2022 20:00:00 +0100</lastBuildDate>
    <atom:link href="" rel="self" type="application/rss+xml" />
    

      
        <item>
        <title>Compiling Ruby. Part 1: Compilers vs. Interpreters</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-1/</link>
        <pubDate>Fri, 02 Dec 2022</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-1/</guid>
        <description>&lt;p&gt;With the (hopefully) convincing &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-0&#34;&gt;motivation&lt;/a&gt; out of the way, we can get to the technical details.&lt;/p&gt;
&lt;h3 id=&#34;compiling-interpreter-interpreting-compiler&#34;&gt;Compiling Interpreter, Interpreting Compiler&lt;/h3&gt;
&lt;p&gt;As mentioned in the motivation, I want to build an ahead-of-time compiler for Ruby. I want it to be compatible with the existing Ruby implementation to fit it naturally into the existing system.&lt;/p&gt;
&lt;p&gt;So the first question I had to answer is - how do I even do it?&lt;/p&gt;
&lt;h4 id=&#34;compilers-vs-interpreters&#34;&gt;Compilers vs. Interpreters&lt;/h4&gt;
&lt;p&gt;The execution model of compiled and interpreted languages is slightly different:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a compiler takes the source program and outputs another program that can be run on any other machine even when the compiler is not on that target machine&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;an interpreter also takes the source program as an input but does not output anything and runs the program right away&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Unlike the compiler, the interpreter must be present on the machine you want to run the program. To build the compiler, I have to somehow combine the interpreter with the program it runs.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a high-level schematic view of a typical compiler and interpreter.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-1/compiler-vs-interpreter.png&#34; alt=&#34;Execution model of an interpreted and compiled program&#34;&gt;&lt;/p&gt;
&lt;p&gt;The compiler is a straightforward one-way process: the source code is parsed, then the machine code is generated, and the executable is produced. The executable also depends on a runtime. The runtime can be either embedded into the executable or be an external entity, but usually both.&lt;/p&gt;
&lt;p&gt;The interpreter is more complex in this regard. It contains everything in one place: parser, runtime, and a virtual machine. Also, note the two-way arrows &lt;code&gt;Parser &amp;lt;-&amp;gt; VM&lt;/code&gt; and &lt;code&gt;Runtime &amp;lt;-&amp;gt; VM.&lt;/code&gt; The reason is that Ruby is a dynamic language. During the regular program execution, a program can read more code from the disk or network and execute it, thus the interconnection between these components.&lt;/p&gt;
&lt;h4 id=&#34;parser--vm--runtime&#34;&gt;Parser + VM + Runtime&lt;/h4&gt;
&lt;p&gt;Arguably, the triple &lt;code&gt;VM&lt;/code&gt; + &lt;code&gt;Parser&lt;/code&gt; + &lt;code&gt;Runtime&lt;/code&gt; can be called &amp;ldquo;a runtime,&amp;rdquo; but I prefer to have some separation of concerns. Here is where I draw the boundaries:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parser: only does the parsing of the source code and converts it into a form suitable for execution via the Virtual Machine (&amp;ldquo;bytecode&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Virtual Machine: the primary &amp;ldquo;computational device,&amp;rdquo; it operates on the bytecode and actually &amp;ldquo;runs&amp;rdquo; the program&lt;/li&gt;
&lt;li&gt;Runtime: machinery required by the parser and VM (e.g., VM state manipulation, resource management, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A naÃ¯ve approach to building the compiler is to tear the interpreter apart: replace VM and runtime with codegen and embed the runtime into the resulting executable. However, the runtime extraction won&amp;rsquo;t work due to the dynamism mentioned above - the resulting executable should be able to parse and run any arbitrary Ruby code.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Side note: an alternative approach is to build a JIT compiler and embed the whole compiler into the executable, but it adds more complexity than I am ready to deal with.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In the end, the solution is simpler - the compiler and the final executable include the whole interpreter. So the final &amp;ldquo;compiling interpreter&amp;rdquo; (or &amp;ldquo;interpreting compiler&amp;rdquo;) looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-1/compiler.png&#34; alt=&#34;Compiling interpreter&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ruby-and-its-many-virtual-machines&#34;&gt;Ruby and its many Virtual Machines&lt;/h3&gt;
&lt;p&gt;Now it&amp;rsquo;s time to discuss the &lt;code&gt;Virtual Machine&lt;/code&gt; component.&lt;/p&gt;
&lt;p&gt;The most widely used Ruby implementation is CRuby, also known as MRI (as in &amp;ldquo;&lt;a href=&#34;https://en.wikipedia.org/wiki/Yukihiro_Matsumoto&#34;&gt;Matz&lt;/a&gt;&amp;rsquo; Ruby Interpreter&amp;rdquo;). It is an interpreter built on top of a custom virtual machine (YARV).&lt;/p&gt;
&lt;p&gt;Another widely used implementation is &lt;a href=&#34;https://mruby.org&#34;&gt;mruby&lt;/a&gt; (so-called &amp;ldquo;embedded&amp;rdquo; Ruby). It is also an interpreter and built on top of another custom VM (RiteVM).&lt;/p&gt;
&lt;p&gt;YARV and RiteVM are rather lightweight virtual machines. Unlike full-fledged system or process-level VMs (e.g., VirtualBox, JVM, CLR, etc.), they only provide a &amp;ldquo;computational device&amp;rdquo; - there is no resource control, sandboxing, etc.&lt;/p&gt;
&lt;h4 id=&#34;stack-vs-registers&#34;&gt;Stack vs. Registers&lt;/h4&gt;
&lt;p&gt;The &amp;ldquo;computational device&amp;rdquo; executes certain operations on certain data.
The operations are encoded in the form of a &amp;ldquo;bytecode.&amp;rdquo; And the data is stored on a &amp;ldquo;virtual stack&amp;rdquo;. Though, the stack is accessed differently.&lt;/p&gt;
&lt;p&gt;YARV accesses the stack implicitly (this is also known as a &amp;ldquo;stack-based VM&amp;rdquo;). RiteVM accesses the stack explicitly via registers (you got it, &amp;ldquo;register-based VM&amp;rdquo;).&lt;/p&gt;
&lt;p&gt;To illustrate the bytecode and the difference between YARV and RiteVM, consider the following artificial examples.&lt;/p&gt;
&lt;p&gt;Stack-based bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;plus&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Register-based bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;load&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;plus&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;print&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The stack-based version uses the stack implicitly, while another version specifies the storage explicitly.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s &amp;ldquo;run&amp;rdquo; both examples to see them in action.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-1/vm-execution.png&#34; alt=&#34;Comparison of stack and register-based VMs&#34;&gt;&lt;/p&gt;
&lt;p&gt;At every step, the VM does something according to the currently running instruction/opcode (underscored lines) and updates the virtual stack.&lt;/p&gt;
&lt;p&gt;Stack-based VM only reads/writes data from/to the place where an arrow points to - this is the top of the virtual stack.&lt;/p&gt;
&lt;p&gt;Register-based VM does the same but has random access to the virtual stack.&lt;/p&gt;
&lt;p&gt;While the underlying machinery is very similar, there are good reasons for picking one or the other form of a VM. Yet, these reasons are out of the scope of this series. Please, consult elsewhere if you want to learn more.
The topic of VMs is huge but fascinating.&lt;/p&gt;
&lt;h4 id=&#34;dispatch-loop&#34;&gt;Dispatch loop&lt;/h4&gt;
&lt;p&gt;Let&amp;rsquo;s consider how the VM works and deals with the bytecode.
YARV and RiteVM use the so-called &amp;ldquo;dispatch loop,&amp;rdquo; which is effectively a for-loop + a huge &lt;code&gt;switch&lt;/code&gt;-statement. Typical pseudocode looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Iterate through each opcode in the bytecode stream
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (opcode in bytecode) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; (opcode) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Take a corresponding action for each separate opcode
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_CODE_1: &lt;span style=&#34;color:#75715e&#34;&gt;/* do something */&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_CODE_2: &lt;span style=&#34;color:#75715e&#34;&gt;/* do something */&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// ... more opcodes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_CODE_N: &lt;span style=&#34;color:#75715e&#34;&gt;/* do something */&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And then, the bodies for the actual opcodes may look as follows.
Stack-based VM:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;Example program:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load 32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; plus
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; print
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_LOAD:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pool[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#75715e&#34;&gt;// pool is some abstract additional storage
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  stack.push(val)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_PLUS:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lhs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stack.pop()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rhs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stack.pop()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lhs &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; rhs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  stack.push(res)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_PRINT:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stack.pop()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  print(val)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And the register-based version for completeness:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;Example program:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load R1 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load R2 32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; plus R1 R1 R2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; print R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// md is some additional opcode metadata
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_LOAD:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  registers[md.reg1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pool[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_PLUS:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  lhs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; registers[md.reg1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  rhs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; registers[md.reg2]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lhs &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; rhs
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  registers[md.reg1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; res
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; OP_PRINT:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; registers[md.reg1]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  print(val)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case, if we know the values behind &lt;code&gt;pool[0]&lt;/code&gt; and the actual values of &lt;code&gt;md.regN&lt;/code&gt;, then we compile the example program to something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load R1 10
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; load R2 32
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; plus R1 R1 R2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; print R1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;R1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;R2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;R1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; R1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; R2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(R1)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;and avoid the whole dispatch loop, but I digress :)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;In the following article, we look into mruby&amp;rsquo;s implementation and virtual machine in more detail - &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-2/&#34;&gt;Compiling Ruby. Part 2: RiteVM&lt;/a&gt;.&lt;/p&gt;
</description>
      </item>
      

    

      
        <item>
        <title>Compiling Ruby. Part 2: RiteVM</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-2/</link>
        <pubDate>Fri, 02 Dec 2022</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-2/</guid>
        <description>&lt;p&gt;mruby (so-called &amp;ldquo;embedded&amp;rdquo; Ruby) is a relatively small Ruby implementation.&lt;/p&gt;
&lt;p&gt;mruby is based on a register-based virtual machine. In the previous article, I mentioned the difference between stack- and register-based VMs, but what is a Virtual Machine?
As obvious as it gets, a Virtual Machine is a piece of software that mimics specific behavior(s) of a Real Machine.&lt;/p&gt;
&lt;p&gt;Depending on the kind of virtual machine, the capabilities may vary.
A VM can mimic a typical computer&amp;rsquo;s complete behavior, allowing us to run any software we&amp;rsquo;d run on a regular machine (think VirtualBox or VMware).
Or it can implement a behavior of an imaginary, artificial machine that doesn&amp;rsquo;t have a counterpart in the real physical world (think JVM or CLR).&lt;/p&gt;
&lt;p&gt;The mruby RiteVM is of a latter kind. It defines a set of &amp;ldquo;CPU&amp;rdquo; operations and provides a runtime to run them. The operations are referred to as bytecode. The bytecode consists of an operation kind (opcode) and its corresponding metadata (registers, flags, etc.).&lt;/p&gt;
&lt;h3 id=&#34;bytecode&#34;&gt;Bytecode&lt;/h3&gt;
&lt;p&gt;Here is a tiny snippet of various RiteVM operations (coming from &lt;code&gt;mruby/ops.h&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OPCODE(NOP,   Z)  &lt;span style=&#34;color:#75715e&#34;&gt;/* no operation */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OPCODE(MOVE,  BB) &lt;span style=&#34;color:#75715e&#34;&gt;/* R(a) = R(b) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OPCODE(ADD,   B)  &lt;span style=&#34;color:#75715e&#34;&gt;/* R(a) = R(a)+R(a+1) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OPCODE(ENTER, W)  &lt;span style=&#34;color:#75715e&#34;&gt;/* arg setup according to flags (23=m5:o5:r1:m5:k5:d1:b1) */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OPCODE(JMP,   S)  &lt;span style=&#34;color:#75715e&#34;&gt;/* pc+=a */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;All the opcodes follow the same form:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;OPCODE(name, operands) &lt;span style=&#34;color:#75715e&#34;&gt;/* comment */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;name&lt;/code&gt; is self-explanatory. The &lt;code&gt;comment&lt;/code&gt; describes (or hints at) an operation&amp;rsquo;s semantics.
The &lt;code&gt;operands&lt;/code&gt; is a bit more tricky and is directly related to the bytecode encoding.&lt;/p&gt;
&lt;p&gt;Each letter in the &lt;code&gt;operands&lt;/code&gt; describes the size of the operand. &lt;code&gt;Z&lt;/code&gt; means that the operand&amp;rsquo;s size is zero bytes (i.e., there is no operand).
&lt;code&gt;B&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;W&lt;/code&gt; all mean one operand, but their sizes are 1, 2, and 3 bytes, respectively.
These definitions can be mixed and matched as needed, but in practice, only the following combinations are used (from &lt;code&gt;mruby/ops.h&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* operand types:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; + BB: 8+8bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; + BBB: 8+8+8bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; + BS: 8+16bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; + BSS: 8+16+16bit
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;as the operation may have up to three operands max.&lt;/p&gt;
&lt;p&gt;The operands are called &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;. The following bytecode string will be decoded differently depending on the operand definition (the &lt;code&gt;42&lt;/code&gt; will be mapped to a corresponding opcode):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;42&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BBB&lt;/code&gt; -&amp;gt; &lt;code&gt;a = 1, b = 2, c = 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;B&lt;/code&gt; -&amp;gt; &lt;code&gt;a = 1, b = undefined, c = undefined&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; is treated as the next opcode&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BS&lt;/code&gt; -&amp;gt; &lt;code&gt;a = 1, b = 2 &amp;lt;&amp;lt; 8 | 3, c = undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W&lt;/code&gt; -&amp;gt; &lt;code&gt;a = 1 &amp;lt;&amp;lt; 16 | 2 &amp;lt;&amp;lt; 8 | 3, b = undefined, c = undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;and so on.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now the comments from the snippet above make more sense:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NOP&lt;/code&gt; does nothing with all its zero operands&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MOVE&lt;/code&gt; copies value from register &lt;code&gt;b&lt;/code&gt; to register &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENTER&lt;/code&gt; maps the operand &lt;code&gt;a&lt;/code&gt; to the flags needed for its logic&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JMP&lt;/code&gt; changes the program counter to point to a new location &lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With all this information, we now understand &lt;em&gt;what&lt;/em&gt; the operations do.
The next question is &lt;em&gt;how&lt;/em&gt; do they do it?&lt;/p&gt;
&lt;h3 id=&#34;bytecode-execution&#34;&gt;Bytecode Execution&lt;/h3&gt;
&lt;p&gt;The bytecode doesn&amp;rsquo;t live in a vacuum. Each bytecode sequence is part of a method. Consider the following example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(a, b)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;puts sum(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can look into its bytecode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mruby&lt;/span&gt; --&lt;span style=&#34;color:#66d9ef&#34;&gt;verbose&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sum.rb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;skipped&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;irep&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x600001390000&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nregs&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nlocals&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;pools&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;syms&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reps&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ilen&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;file: &lt;span style=&#34;color:#a6e22e&#34;&gt;sum.rb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;000&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TCLASS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;002&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;METHOD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;I&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0x600001390050&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;005&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DEF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;008&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;011&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;014&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SSEND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x02&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;018&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SSEND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;puts&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x01&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;022&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RETURN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;024&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;STOP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;irep&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x600001390050&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nregs&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nlocals&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;pools&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;syms&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;reps&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ilen&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;local&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;variable&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;names&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; R1:&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; R2:&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; R3:&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;amp;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;file: &lt;span style=&#34;color:#a6e22e&#34;&gt;sum.rb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;000&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ENTER&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x80000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;004&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MOVE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;; R1:a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;007&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MOVE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R5&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;; R2:b
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;010&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ADD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;012&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RETURN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The bytecode sequence is part of the &lt;code&gt;mrb_irep&lt;/code&gt; struct, which is subsequently part of the &lt;code&gt;RProc&lt;/code&gt; struct, which corresponds to a Ruby method (procedure?) object.&lt;/p&gt;
&lt;p&gt;The distinction is necessary as &lt;code&gt;RProc&lt;/code&gt; is a higher-level abstraction over an executable code, which might be either a RiteVM bytecode or a C function. Additionally, there is a distinction between a &lt;code&gt;lambda&lt;/code&gt;, a &lt;code&gt;block&lt;/code&gt;, and a &lt;code&gt;method&lt;/code&gt;. Yet, we will only focus on the bytecode parts and ignore all the lambda/block/method shenanigans.&lt;/p&gt;
&lt;p&gt;In the &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-1/#ruby-and-its-many-virtual-machines&#34;&gt;previous article&lt;/a&gt;, I briefly described the dispatch loop and how a VM interacts with the virtual stack. The description is not precise but accurate and catches the essential details.&lt;/p&gt;
&lt;p&gt;Execution of each &lt;code&gt;RProc&lt;/code&gt; requires a virtual stack to operate on the data, but it also requires some additional metadata. The &amp;ldquo;metadata&amp;rdquo; is part of the so-called &lt;code&gt;mrb_callinfo&lt;/code&gt; struct. This concept is known as &lt;code&gt;stack frame&lt;/code&gt; or &lt;code&gt;activation record&lt;/code&gt;.
The virtual stack is stored separately but is part of the &lt;code&gt;mrb_callinfo&lt;/code&gt; (sort of).
The virtual stack is essential as it is the only way to communicate between different operations and different &lt;code&gt;RProc&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;Here is what happens during bytecode execution:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mrb_callinfo&lt;/code&gt; is created from an &lt;code&gt;RProc&lt;/code&gt; and is put onto the &amp;ldquo;call info&amp;rdquo; stack or simply a call stack. The new &lt;code&gt;mrb_callinfo&lt;/code&gt; points to a new location of the shared virtual stack (see the first picture below).&lt;/li&gt;
&lt;li&gt;Each operation in &lt;code&gt;RProc&lt;/code&gt;&amp;rsquo;s &lt;code&gt;mrb_irep&lt;/code&gt; is executed in the context of the top &lt;code&gt;mrb_callinfo&lt;/code&gt; on the call stack. The virtual stack and state of the VM are updated accordingly.&lt;/li&gt;
&lt;li&gt;When any &amp;ldquo;sendable&amp;rdquo; (&lt;code&gt;OP_SEND&lt;/code&gt;, &lt;code&gt;OP_SSEND&lt;/code&gt;, &lt;code&gt;OP_SENDBV&lt;/code&gt;, etc.) operation is encountered, we move to step 1.&lt;/li&gt;
&lt;li&gt;When any &amp;ldquo;returnable&amp;rdquo; (&lt;code&gt;OP_RETURN&lt;/code&gt;, &lt;code&gt;OP_RETURN_BLK&lt;/code&gt;) operation is encountered, then the operand is put into the &amp;ldquo;return register&amp;rdquo; (for consumption by the caller), and the call stack is popped, effectively removing &lt;code&gt;mrb_callinfo&lt;/code&gt; created at step 1.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here is how it looks in memory:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-2/bytecode-execution-high-level.png&#34; alt=&#34;Bytecode Execution Highlevel View&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mrb_state&lt;/code&gt; (the state of the whole VM) has a stack of &lt;code&gt;mrb_context&lt;/code&gt;s (more on them in a later article). Each &lt;code&gt;mrb_context&lt;/code&gt; maintains the stack of &lt;code&gt;mrb_callinfo&lt;/code&gt; (the call stack). Each &lt;code&gt;mrb_context&lt;/code&gt; owns a virtual stack, which is shared among several &lt;code&gt;mrb_callinfo&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This way, the caller prepares the stack for the callee.&lt;/p&gt;
&lt;p&gt;As a reminder, here is the bytecode from the example above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-asm&#34; data-lang=&#34;asm&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;top:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TCLASS&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;METHOD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;I&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0x600001390050&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;DEF&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R3&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;LOADI&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SSEND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x02&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SSEND&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; :&lt;span style=&#34;color:#66d9ef&#34;&gt;puts&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;n&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x01&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;RETURN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;STOP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sum:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ENTER&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0x80000&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;MOVE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R1&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;; R1:a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;MOVE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R5&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R2&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;; R2:b
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ADD&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;RETURN&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;R4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is how the shared stack looks from the perspective of both the top-level method &lt;code&gt;top&lt;/code&gt; and the method &lt;code&gt;sum&lt;/code&gt;: by the time the first &lt;code&gt;SSEND&lt;/code&gt; operand (&amp;ldquo;send to self&amp;rdquo;) is executed, all the values are ready for consumption by the callee.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-2/bytecode-execution.png&#34;
style=&#34; display: block;
margin-left: 0;
margin-right: auto;
width: 80%;
height: auto;&#34; /&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Hopefully, now you better understand how RiteVM uses bytecode, and we are one step closer to the actual fun part - compilation!&lt;/p&gt;
&lt;p&gt;The following article will examine MLIR and how it fits the whole compilation story.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://lowlevelbits.org/subscribe/&#34;&gt;Don&amp;rsquo;t miss the next part!&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
      

    

      
        <item>
        <title>Compiling Ruby. Part 0: Motivation</title>
        <link>https://lowlevelbits.org/compiling-ruby-part-0/</link>
        <pubDate>Fri, 02 Dec 2022</pubDate>
        <author>alex@lowlevelbits.org (Alex Denisov)</author>
        <guid>https://lowlevelbits.org/compiling-ruby-part-0/</guid>
        <description>&lt;p&gt;For the last couple of years, I&amp;rsquo;ve been working on a fun side project called &lt;a href=&#34;https://dragonruby.org/toolkit/game&#34;&gt;DragonRuby Game Toolkit&lt;/a&gt;, or GTK for short.&lt;/p&gt;
&lt;p&gt;GTK is a professional-grade 2D game engine. Among the many incredible features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;you can build games in Ruby&lt;/li&gt;
&lt;li&gt;it targets many (like, many!) platforms (Windows, Linux, macOS, iOS, Android, WASM, Nintendo Switch, Xbox, PlayStation, Oculus VR, Steam Deck)&lt;/li&gt;
&lt;li&gt;super lightweight (~3.5 megabytes)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dragonruby.org/toolkit/game&#34;&gt;and many more really&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GTK is built on top of a slightly customized mruby runtime and allows you to write games purely in Ruby. It comes with all the batteries included, but if you need more in a specific case, you can always fall back to C via the C extensions mechanism.&lt;/p&gt;
&lt;p&gt;From a user perspective, the end product (the game) looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-0/end-product.png&#34; alt=&#34;End Product&#34;&gt;&lt;/p&gt;
&lt;p&gt;While the engine itself is pretty fast, what annoys me personally (from the aesthetic point of view) is that we cannot fully optimize the C extensions as they are compiled separately from the rest of the engine.&lt;/p&gt;
&lt;p&gt;Looking at the picture, we have four components of the game:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the engine&amp;rsquo;s runtime (Ruby)&lt;/li&gt;
&lt;li&gt;the engine&amp;rsquo;s runtime (C)&lt;/li&gt;
&lt;li&gt;the game code (Ruby)&lt;/li&gt;
&lt;li&gt;the game code (C)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Suppose we want to optimize all the C code together. In that case, we&amp;rsquo;d have to ship the runtime in some &amp;lsquo;common&amp;rsquo; denominator form (e.g., &lt;a href=&#34;https://lowlevelbits.org/bitcode-demystified/&#34;&gt;LLVM Bitcode&lt;/a&gt;), then compile the C extension into the same form, optimize it all together and then link into an executable.&lt;/p&gt;
&lt;p&gt;This is doable, but while I was thinking about this problem I&amp;rsquo;ve found even bigger (and much more interesting) &amp;lsquo;problem&amp;rsquo; - what about all that Ruby code? Can we also compile it to some common form and then optimize it with the rest of the C code out there?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://lowlevelbits.org/img/compiling-ruby-0/optimizations.png&#34; alt=&#34;Optimizations&#34;&gt;&lt;/p&gt;
&lt;p&gt;The answer is - definitely yes! We just need to build a compiler that would do that job.&lt;/p&gt;
&lt;p&gt;At the time of writing, the compiler is far from being done, but it works reasonably well, and I can successfully compile and run more than half of the mruby test suite.&lt;/p&gt;
&lt;p&gt;As a sneak peek, here is an output from the test suite:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/opt/DragonRuby/FireStorm/cmake-build-llvm-14-asan/tests/MrbTests/firestorm_mrbtest
mrbtest - Embeddable Ruby Test

............................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................?.........................................................................................................................
Skip: File.expand_path (with ENV)
 Total: 934
 OK: 933
 KO: 0
 Crash: 0
 Warning: 0
 Skip: 1
 Time: 0.45 seconds

Process finished with exit code 0
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;I hope this motivation gives you enough information on why someone would do what I am doing!&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s take a look at the approach I am taking to solve this problem - &lt;a href=&#34;https://lowlevelbits.org/compiling-ruby-part-1/&#34;&gt;Compilers vs. Interpreters&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
      

    
  </channel>
</rss>
